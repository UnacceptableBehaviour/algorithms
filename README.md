# Introduction to Algorithms (MIT 6.006)
REPO: [algorithms](https://github.com/UnacceptableBehaviour/algorithms)  
See [References](#references) for links to course content  


## Abstract
Work notes from Introduction to [Algorithms MIT 6.006](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/syllabus/) course [lectures on ytube](https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)   
[MIT 6.006 course info]() ~ 
[Lectures & Recitations](http://courses.csail.mit.edu/6.006/fall11/notes.shtml) ~ 
[Resources - Python / Latex](http://courses.csail.mit.edu/6.006/fall11/resources.shtml) ~ 
[Quizzes/Exams](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/)  


## Progress
KEY: (:white_check_mark:) watched, (:mag:) rewatch, (:flashlight:) unseen / to watch, (:question:) problem / open question  
CODE: (:seedling:) code complete, (:cactus:) incomplete / needs work, (:lemon:) not happy / code smells,  

| Lectures                                                                                                                                                                         | Recitations                                                                                                                                                                                                                                    | Problem Sets                                                                                                                                                      | Solutions                                                                                                                                                        | Example Code                                                                                                                                                                                                                                                                               | Implementation                                                                                                                                                                                                                                               |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| :white_check_mark: [01. Algorithmic Thinking, Peak Finding](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=2&t=3s)                    | :flashlight: [R01. Asymptotic Complexity, Peak Finding](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/recitation-videos/recitation-1-asymptotic-complexity-peak-finding/) | [Set 1 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf)   | [Set 1](https://github.com/UnacceptableBehaviour/algorithms#problem-set-1)                                                                                       | [DocDistance Optimisations](https://github.com/UnacceptableBehaviour/algorithms/tree/master/lecture_code/L2_doc_distance)   [PS1 - Problem Code](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/ps1.zip)   |                                                                                                                                                                                                                                                              |
| :white_check_mark: [02. Models of Computation, Document Distance](https://www.youtube.com/watch?v=Zc54gFhdpLA&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=3&t=117s)            | :flashlight: [R02. Python Cost Model, Document Distance](https://www.youtube.com/watch?v=j0upQLUrpM8)                                                                                                                                          |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :white_check_mark: [03. Insertion Sort, Merge Sort](https://www.youtube.com/watch?v=Kg4bqzAqRBM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=4&t=1953s)                         | :flashlight: [R03. Document Distance, Insertion and Merge Sort](https://www.youtube.com/watch?v=4iXLnF3hExw&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=27)                                                                                  | [Set 2 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps2.pdf)   |                                                                                                                                                                  | [PS2 - Problem Code](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/ps2.zip)                                                                                                                               | :seedling: [merge.sort-P3](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/merge_sort.py)                                                                                                                                              |
| :white_check_mark: [04. Heaps and Heap Sort](https://www.youtube.com/watch?v=B7hVxCmfPtM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=5&t=2064s)                                |                                                                                                                                                                                                                                                |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            | :seedling: [Heap-P3](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/heap_ify.py)                                                                                                                                                      |
| :white_check_mark: [05. Binary Search Trees, BST Sort](https://www.youtube.com/watch?v=9Jry5-82I68&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=6&t=1s)                         | :white_check_mark: [R05. Recursion Trees, Binary Search Trees](https://www.youtube.com/watch?v=r5pXu1PAUkI&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=28)                                                                                   |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            | :seedling: [BST-P3](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/binary_search_tree.py)                                                                                                                                             |
| :white_check_mark: [06. AVL Trees, AVL Sort](https://www.youtube.com/watch?v=FNeL18KsWPc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=7&t=1913s)                                | :white_check_mark: [R06. AVL Trees](https://www.youtube.com/watch?v=IWzYoXKaRIc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=29)                                                                                                              |                                                                                                                                                                   |                                                                                                                                                                  | [AVL / BST](https://github.com/UnacceptableBehaviour/algorithms/tree/master/lecture_code/L6_BST_AVL_trees)                                                                                                                                                                                 | :seedling: [AVL-P3](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/AVL.py)                                                                                                                                                            |
| :white_check_mark: [07. Counting Sort, Radix Sort, Lower Bounds for Sorting](https://www.youtube.com/watch?v=Nz1KZXbghj8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=8&t=301s) | :white_check_mark: [R07. Comparison Sort, Counting and Radix Sort](https://www.youtube.com/watch?v=9bkvws_vqLU&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=30)                                                                               | [Set 3 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps3.pdf)   |                                                                                                                                                                  | [PS3 - Problem Code](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/ps3.zip)                                                                                                                               |                                                                                                                                                                                                                                                              |
| :white_check_mark: [08. Hashing with Chaining](https://www.youtube.com/watch?v=0M_kIqhwbFo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9&t=0s)                                 | :white_check_mark: [R08. Simulation Algorithms](https://www.youtube.com/watch?v=eGSXsaJ-BlY&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=31)                                                                                                  |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            | :seedling: [Hash.w.Chaining-P3](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/assoc_array_dict.py)   :cactus: [Hash Div/Mul Word search](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/string_match_hash.py) |
| :white_check_mark: [09. Table Doubling, Karp](https://www.youtube.com/watch?v=BRO7mVIFt08&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=10&t=0s)                                 | :mag: [R09. Rolling Hashes, Amortized Analysis](https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=32)                                                                                                  | [Set 4 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps4.pdf)   |                                                                                                                                                                  | [PS4 - Problem Code](http://ocw.mit.edu/ans7870/6/6.006/f11/ps4.tar.gz)                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                              |
| No lecture 9b                                                                                                                                                                    | :flashlight: [R09b - DNA Sequence Matching](https://www.youtube.com/watch?v=-DwGrJ8JxDc)                                                                                                                                                       |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: [10. Open Addressing, Cryptographic Hashing](https://www.youtube.com/watch?v=rvdJDijO2Ro&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=10)                          | :flashlight: R10. Quiz 1 Review-                                                                                                                                                                                                               | [Quiz 1](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_quiz1.pdf)          | [Quiz 1](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_quiz1_sol.pdf)     |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 11. Integer Arithmetic, Karatsuba Multiplication                                                                                                                    | :flashlight: R11. Principles of Algorithm Design                                                                                                                                                                                               | [Set 5 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps5.pdf)   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 12. Square Roots, Newton's Method                                                                                                                                   | :flashlight: R12. Karatsuba Multiplication, Newton's Method                                                                                                                                                                                    |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 13. Breadth                                                                                                                                                         | :flashlight: R13. Breadth                                                                                                                                                                                                                      |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 14. Depth                                                                                                                                                           | :flashlight: R14. Depth                                                                                                                                                                                                                        | [Set 6 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps6.pdf)   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 15. Single                                                                                                                                                          | :flashlight: R15. Shortest Paths                                                                                                                                                                                                               |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 16. Dijkstra                                                                                                                                                        | :flashlight: R16. Rubik's Cube, StarCraft Zero                                                                                                                                                                                                 |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 17. Bellman                                                                                                                                                         | :flashlight: R18. Quiz 2 Review                                                                                                                                                                                                                | [Quiz 2](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_quiz2.pdf)          | [Quiz 2](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_quiz2_sol.pdf)     |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 18. Speeding up Dijkstra                                                                                                                                            | :flashlight: R19. Dynamic Programming - Crazy Eights, Shortest Path                                                                                                                                                                            | [Set 7 PDF](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps7.pdf)   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 19. Dynamic Programming I - Fibonacci, Shortest Paths                                                                                                               | :flashlight: R20. Dynamic Programming - Blackjack                                                                                                                                                                                              |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 20. Dynamic Programming II - Text Justification, Blackjack                                                                                                          | :flashlight: R21. Dynamic Programming - Knapsack Problem                                                                                                                                                                                       |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 21. DP III - Parenthesization, Edit Distance, Knapsack                                                                                                              | :flashlight: R22. Dynamic Programming - Dance Dance Revolution                                                                                                                                                                                 |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 22. DP IV - Guitar Fingering, Tetris, Super Mario Bros.                                                                                                             | :flashlight: R23. Computational Complexity                                                                                                                                                                                                     |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 23. Computational Complexity                                                                                                                                        | :flashlight: R24. Final Exam Review                                                                                                                                                                                                            | [Final Exam](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_final.pdf)      | [Final Exam](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/MIT6_006F11_final_sol.pdf) |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |
| :flashlight: 24. Topics in Algorithms Research                                                                                                                                   |                                                                                                                                                                                                                                                |                                                                                                                                                                   |                                                                                                                                                                  |                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                              |



## Contents  
1. [Abstract](#abstract)  
2. [Progress](#progress)  
3. [Contents](#contents)  
4. [AIM:](#aim)  
5. [Intoduction to algorithms MIT - part 1 / 3:](#intoduction-to-algorithms-mit---part-1--3)  
6. [Unit 1: Introduction](#unit-1-introduction)  
	1. [L1 - Algorithmic thinking, peak finding](#l1---algorithmic-thinking-peak-finding)  
		1. [Vid contents](#vid-contents)  
		2. [Notes on time complexity (always worst case complexity)](#notes-on-time-complexity-always-worst-case-complexity)  
		3. [**Symbols:**](#symbols)  
		4. [**Time Complexity - Order Severity**](#time-complexity---order-severity)  
		5. [Useful maths equations](#useful-maths-equations)  
	2. [R1 - maths & code](#r1---maths--code)  
		1. [Vid contents](#vid-contents)  
		2. [Maths notes](#maths-notes)  
	3. [L2 - Models of computation, Python cost model, document distance](#l2---models-of-computation-python-cost-model-document-distance)  
		1. [Vid contents](#vid-contents)  
		2. [Model of computation:](#model-of-computation)  
		3. [Python Model  - Computational Steps](#python-model----computational-steps)  
		4. [Document distance (problem and algorithms)](#document-distance-problem-and-algorithms)  
		5. [Examples Document distance code:](#examples-document-distance-code)  
		6. [Maths notes](#maths-notes)  
	4. [R2 - doc distance optimisation - python cost model](#r2---doc-distance-optimisation---python-cost-model)  
		1. [Vid contents](#vid-contents)  
		2. [Setting up for profiling](#setting-up-for-profiling)  
		3. [Code of code](#code-of-code)  
		4. [Comparing versions](#comparing-versions)  
		5. [Maths notes](#maths-notes)  
7. [Problem set 1.](#problem-set-1)  
	1. [Problem 1-1. [15 points] Asymptotic Practice   Calculating asymptotic complexity (Big O notation)](#problem-1-1-15-points-asymptotic-practice--calculating-asymptotic-complexity-big-o-notation)  
	2. [Problem 1-2. [15 points] Recurrence Relation Resolution](#problem-1-2-15-points-recurrence-relation-resolution)  
	3. [Problem 1-3. [16 points] Peak-Finding Correctness](#problem-1-3-16-points-peak-finding-correctness)  
	4. [Problem 1-4. [16 points] Peak-Finding Efficiency](#problem-1-4-16-points-peak-finding-efficiency)  
	5. [Problem 1-5. [19 points] Peak-Finding Proof](#problem-1-5-19-points-peak-finding-proof)  
	6. [Problem 1-6. [19 points] Peak-Finding Counterexamples 	data that shows how the python algorithms can fail](#problem-1-6-19-points-peak-finding-counterexamplesdata-that-shows-how-the-python-algorithms-can-fail)  
8. [Unit 2: Sorting and Trees](#unit-2-sorting-and-trees)  
	1. [L3 - Insertion sort, merge sort](#l3---insertion-sort-merge-sort)  
		1. [Insertion sort](#insertion-sort)  
		2. [Merge Sort](#merge-sort)  
	2. [L4 - Heaps and heap sort](#l4---heaps-and-heap-sort)  
		1. [**DATA STRUCTURE - Priority Q - L4 3m33**](#data-structure---priority-q---l4-3m33)  
		2. [Priority Queue](#priority-queue)  
		3. [Heap](#heap)  
			1. [Heap as a tree navigation](#heap-as-a-tree-navigation)  
			2. [Heap as a tree properties](#heap-as-a-tree-properties)  
			3. [Max_heapify](#maxheapify)  
	3. [L5 - Binary search trees, BST sort](#l5---binary-search-trees-bst-sort)  
		1. [**DATA STRUCTURE - BST - Binary search trees**](#data-structure---bst---binary-search-trees)  
		2. [Vid contents](#vid-contents)  
		3. [Augmented BST - 37m - node_count_before - RANK](#augmented-bst---37m---nodecountbefore---rank)  
	4. [R5 - Recursion Trees, Binary Search Trees](#r5---recursion-trees-binary-search-trees)  
		1. [Vid contents](#vid-contents)  
		2. [Maths notes](#maths-notes)  
		3. [get_successor()](#getsuccessor)  
		4. [delete()](#delete)  
	5. [L6 - AVL trees, AVL sort](#l6---avl-trees-avl-sort)  
		1. [**DATA STRUCTURE - AVL tree - R6 50m**](#data-structure---avl-tree---r6-50m)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [TERMS](#terms)  
		5. [Maths notes - AVL tree (19-25m) - height analysis v1](#maths-notes---avl-tree-19-25m---height-analysis-v1)  
		6. [Maths notes - AVL tree (26m) - height analysis v2](#maths-notes---avl-tree-26m---height-analysis-v2)  
	6. [R6 - AVL trees](#r6---avl-trees)  
		1. [Vid contents](#vid-contents)  
		2. [BST review](#bst-review)  
		3. [AVL properties](#avl-properties)  
		4. [Maths notes](#maths-notes)  
	7. [L7 - Counting sort, radix sort, lower bounds for sorting and searching](#l7---counting-sort-radix-sort-lower-bounds-for-sorting-and-searching)  
		1. [**DATA STRUCTURE - Counting sort**](#data-structure---counting-sort)  
		2. [**DATA STRUCTURE - Radix sort**](#data-structure---radix-sort)  
		3. [**Vid contents**](#vid-contents)  
		4. [Sorting in Linear-Time](#sorting-in-linear-time)  
			1. [Counting Sort - 37m](#counting-sort---37m)  
			2. [Radix Sort - 45m](#radix-sort---45m)  
	8. [R7 - Algos so far summary -](#r7---algos-so-far-summary--)  
		1. [Vid contents](#vid-contents)  
		2. [Summary Sorting Algos So far:](#summary-sorting-algos-so-far)  
		3. [Maths notes](#maths-notes)  
9. [Problem set 2.](#problem-set-2)  
		1. [2-1 Fractal rendering [40pts]](#2-1-fractal-rendering-40pts)  
		2. [2-2 Digital Circuit Simulation [60pt]](#2-2-digital-circuit-simulation-60pt)  
10. [Unit 3: Hashing](#unit-3-hashing)  
	1. [L8 - Hashing with chaining - (dictionary / associative array)](#l8---hashing-with-chaining---dictionary--associative-array)  
		1. [**DATA STRUCTURE**](#data-structure)  
	2. [R8 - Simulation Algorithms](#r8---simulation-algorithms)  
		1. [Maths notes](#maths-notes)  
	3. [L9 - Table doubling, Karp-Rabin](#l9---table-doubling-karp-rabin)  
	4. [R9 - Rolling Hashes, Amortized Analysis](#r9---rolling-hashes-amortized-analysis)  
		1. [Maths notes](#maths-notes)  
	5. [R9b - 9b: DNA Sequence Matching](#r9b---9b-dna-sequence-matching)  
		1. [Maths notes](#maths-notes)  
11. [Problem set 3 - Range Query (Analysis) / Circuit Layout (Tool optimisation)](#problem-set-3---range-query-analysis--circuit-layout-tool-optimisation)  
	1. [3-1 Range Query - AVL tree](#3-1-range-query---avl-tree)  
	2. [3-2 Tool Optimisation [55 points]](#3-2-tool-optimisation-55-points)  
		1. [REFS - alt profilers](#refs---alt-profilers)  
	3. [L10 - Open addressing, cryptographic hashing](#l10---open-addressing-cryptographic-hashing)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Example problem](#example-problem)  
		3. [Maths notes](#maths-notes)  
	4. [R10 - Quiz 1 review](#r10---quiz-1-review)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Example problem](#example-problem)  
		3. [Maths notes](#maths-notes)  
12. [Problem set 4](#problem-set-4)  
13. [Quiz 1](#quiz-1)  
14. [Unit 4: Numerics](#unit-4-numerics)  
	1. [L11 - Integer arithmetic, Karatsuba multiplication](#l11---integer-arithmetic-karatsuba-multiplication)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	2. [R11 - Principles of Algorithm Design](#r11---principles-of-algorithm-design)  
		1. [Vid contents](#vid-contents)  
		2. [Example problem](#example-problem)  
		3. [Maths notes](#maths-notes)  
15. [Problem set 5 out](#problem-set-5-out)  
	1. [L12 - Square roots, Newton's method](#l12---square-roots-newtons-method)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
16. [Unit 5: Graphs](#unit-5-graphs)  
	1. [L13 - Breadth-first search (BFS)](#l13---breadth-first-search-bfs)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	2. [L14	Depth-first search (DFS), topological sorting](#l14depth-first-search-dfs-topological-sorting)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
17. [Problem set 5 due](#problem-set-5-due)  
18. [Problem set 6 out](#problem-set-6-out)  
19. [Unit 6: Shortest Paths](#unit-6-shortest-paths)  
	1. [L15 - Single-source shortest paths problem](#l15---single-source-shortest-paths-problem)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	2. [L16 - Dijkstra](#l16---dijkstra)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	3. [L17 - Bellman-Ford](#l17---bellman-ford)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	4. [L18 - Speeding up Dijkstra](#l18---speeding-up-dijkstra)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
20. [Unit 7: Dynamic Programming](#unit-7-dynamic-programming)  
	1. [L19 - Memoization, subproblems, guessing, bottom-up; Fibonacci, shortest paths](#l19---memoization-subproblems-guessing-bottom-up-fibonacci-shortest-paths)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
21. [Problem set 7 out](#problem-set-7-out)  
	1. [L20 - Parent pointers; text justification, perfect-information blackjack](#l20---parent-pointers-text-justification-perfect-information-blackjack)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	2. [L21 - String subproblems, psuedopolynomial time; parenthesization, edit distance, knapsack](#l21---string-subproblems-psuedopolynomial-time-parenthesization-edit-distance-knapsack)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	3. [L22 - Two kinds of guessing; piano/guitar fingering, Tetris training, Super Mario Bros.[vid]()](#l22---two-kinds-of-guessing-pianoguitar-fingering-tetris-training-super-mario-brosvid)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
22. [Problem set 7 due](#problem-set-7-due)  
23. [Unit 8: Advanced Topics](#unit-8-advanced-topics)  
	1. [L23 - Computational complexity](#l23---computational-complexity)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
	2. [24 - Algorithms research topics](#24---algorithms-research-topics)  
		1. [**DATA STRUCTURE**](#data-structure)  
		2. [Vid contents](#vid-contents)  
		3. [Example problem](#example-problem)  
		4. [Maths notes](#maths-notes)  
24. [Glossary of terms](#glossary-of-terms)  
25. [How To s](#how-to-s)  
	1. [How so I plot a chart with python?](#how-so-i-plot-a-chart-with-python)  
	2. [How to setup autogenerate README.md file from RTF notes?](#how-to-setup-autogenerate-readmemd-file-from-rtf-notes)  
	3. [How do I autogenerate README.md file from RTF?](#how-do-i-autogenerate-readmemd-file-from-rtf)  
	4. [How can I add maths formulas to README.md?](#how-can-i-add-maths-formulas-to-readmemd)  
		1. [Manually: Generate math image and embed it.](#manually-generate-math-image-and-embed-it)  
		2. [Automagically:  Install texify.](#automagically--install-texify)  
		3. [How can I get rid of ref numbers, or get them to increment at least?](#how-can-i-get-rid-of-ref-numbers-or-get-them-to-increment-at-least)  
26. [References](#references)  
	1. [Intoduction to algorithms MIT (part 1 / 3):](#intoduction-to-algorithms-mit-part-1--3)  
	2. [LaTex example setup and doc repo: https://github.com/UnacceptableBehaviour/latex_maths](#latex-example-setup-and-doc-repo-httpsgithubcomunacceptablebehaviourlatexmaths)  
	3. [Design & Analysis of Algorithms (part 2 / 3)](#design--analysis-of-algorithms-part-2--3)  
	4. [Advanced Algorithms 2008 (part 3 / 3)](#advanced-algorithms-2008-part-3--3)  


## AIM:  




Create an algorithms reference, and aide-memoire  

In the mean time here are two great resources:  
Big O Cheat Sheet: [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)  
Open data structures: [http://opendatastructures.org/](http://opendatastructures.org/)  


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Intoduction to algorithms MIT - part 1 / 3:  
[LECTURE PLAYLIST on YOUTUBE](https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)  
[COURSE INFO @ MIT](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)  
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



## Unit 1: Introduction
### L1 - Algorithmic thinking, peak finding	
[vid](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=2&t=423s) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec01.pdf)  

#### Vid contents
0m - 15m45  Introduction to course and 8 units its separated into - mentions prerequisite Maths 6.042  
15m45 - 36m20 Peak finding 1D  
17m50 defining the solution to 1D algorithm  
27m40 Divide & conquer (binary search)  
32m30 Recurence relation overview  
36m20 -  Peak finding 2D  
37m13 defining the solution to 2D algorithm - note a >= b - means   
38m Greedy ascent algorithm - find highest neighbour, go in that direction, loop  
40m43 Greedy ascent algorithm complexity Θ(mn) (rown x columns) O(n^2) IE BAD!  
43m 2D binary search  
46m EG 1 - incorrect search  
47m45 EG2 - working version  
51m25 Recurrence for 2D algorithm  
54m15 Note on PS1 - Prove one algorithm is correct & find counter examples for the rest (which are not)  
  
Peak finding: assuming **single peak**, and   
Initial look at 1d peak finding (an single index array)
a) linear
b) search by halves - height of a binary tree is logn (log base 2)

34m50	T(n) = Θ(1) + . . . Θ(1) = Θ(logn)  
Binary search tree is formed by the search by halves algorithm and the number of **steps to find the target is the height of the tree.**  
See R1 31m & 43m

Question: What comprises work due to n and what can be counted as constant time Θ(1) and disregarded!  

51m48  
$$
\begin{equation}
  binary\;tree\;height\;h = log_2n
\end{equation}
\begin{equation}
  T(n,m) = T(n, \frac{m}{2}) + \Theta(n)
\end{equation}
\begin{equation}
  T(n,m) = \Theta(n)\;.\;.\;\Theta(n)\;(log_2m\;times\;for\;m\;columns)
\end{equation}
\begin{equation}
  T(n,m) = \Theta(nlogm) = \Theta(nlogn)\;\text{where n=m}
\end{equation}
$$
m = columns  
n = rows  
**That all makes sense but binary search relies on sorted data and the data in the example is NOT sorted.**  
Swapping 14 & 20 would result in a fail, maybe itll make sense later!  


#### Notes on time complexity (always worst case complexity)
aka: Big O notation / Bachmann-Landau notation / asymptotic notation.  

See [Time Complexity of Common Data Structures](https://www.bigocheatsheet.com/) great summary of array sorting algorithm complexity and data structure operations   

#### **Symbols:**  
Big O Notation [wikipedia](https://en.wikipedia.org/wiki/Big_O_notation) Family of Bachmann-Landau notations    
Big O Notation [notes from MIT](https://web.mit.edu/16.070/www/lecture/big_o.pdf) p3 - from wikipedia?  
Maths [Symbols by subject](https://en.wikipedia.org/wiki/List_of_mathematical_symbols_by_subject) Asymptotic behaviour   

The following symbols o, Ω, ω, and Θ, are used to describe differing kinds of bounds on asymptotic growth rates.  
O - big O - describes the asymptotic behaviour of functions WORST case or UPPER bound (common in **CompSci**)  
Θ - big Theta - describes the asymptotic behaviour of functions AVERAGE case - LOWER BOUND & UPPER BOUND (common in **CompSci**)  
(note the upper and lower bounds are the same function that only differs by a constant)
Ω - big Omega - BEST case or LOWER bound (common in **CompSci**)  
o - little O - loose upper bound (common in Maths rare in CompSci)  
ω - little omega - rough estimate of the order of the growth (rarely used)  
T(n) - function defining the exact Time or number of steps to complete an algorithm for n items  

The rate of growth of a function is also known as its **order**.  

Great resource about [Common Time Complexities](https://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities)  

#### **Time Complexity - Order Severity**
Where c is a constant and n is the number of steps:  
**LOW**  
constant time - O(1)  
logarithmic time - O(log n)  
linear time - O(n)  
quasilinear time  - O(n log n)  
polylogarithmic time  - O((log n) ^ c)  
quadratic time - O(n^2)  
polynomial time - O(n^c) where constant c > 1  
exponential time - O(2^n)  
factorial time - O(n!)  
**HIGH**  

![Big O graphs](https://upload.wikimedia.org/wikipedia/commons/7/7e/Comparison_computational_complexity.svg)  
Image source: [wikipedia](https://upload.wikimedia.org/wikipedia/commons/7/7e/Comparison_computational_complexity.svg) 
Licence: [Attribution-Share Alike 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/deed.en)  

The above list is useful because of the following fact: if a function f(n) is a sum of functions, one of which grows faster than the others, then the faster growing one determines the order of f(n).

If a function is made up of multiple components, (nearly always) the highest order is used:
(this is because big O is the upper bound (worst case) and highest order will be fastest growing and eventually dwarf the other terms)  
Egs
$$
\begin{align}
f(n) = 10log(n) + 5(log(n))^3 + 7n + 3n^2 + 6n^3,  then f(n) = O(n^3)
\end{align}
$$

Simplified set theory? Some people (mostly mathematicians, as opposed to computer scientists) prefer to define O(g(x)) as a set-valued function, whose value is all functions that do not grow faster then g(x), and use set membership notation to indicate that a specific function is a member of the set thus defined. Both forms are in common use, but the sloppier equality notation is more common at present.  
		
[Time Complexity Graph](https://en.wikipedia.org/wiki/Time_complexity)  
[Python matplotlib chart browser](https://python-graph-gallery.com/122-multiple-lines-chart/)  
[Python matplotlib multiple line simple](https://stackoverflow.com/questions/4805048/how-to-get-different-colored-lines-for-different-plots-in-a-single-figure)  
[Setting yAxis logarithmic](https://matplotlib.org/3.1.1/gallery/scales/scales.html)  

#### Useful maths equations
Fundamental to binary tree algorithms:
$$
\begin{equation}
  binary\;tree\;height\;h = logn
\end{equation}
$$




### R1 - maths & code
[vid](https://www.youtube.com/watch?v=P7frcB_-g4w&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=25) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/) ~ 
[Code - PSet 1](https://github.com/UnacceptableBehaviour/algorithms/tree/master/problems/MIT6_006F11_ps1)  
Reading: 

#### Vid contents
2m - 13m40 Asymptotic complexity Ω, Θ, O  
13m40 - common worst case runtimes  
16m - example asymptotic notation  
23m - log(log(n))  
25m - log ( N choose N/2 ) = Θ(n)    
31m - 43m peak finding 1d - running time T(n)
43m - 53m peak finding - running time T(n)

NOTE
g(x) = O(f(x)) - UPPER bound - O - big O
g(x) = Θ(f(x)) - UPPER & LOWER bound - Θ - big Theta
g(x) = Ω(f(x)) - LOWER bound - Ω - big Omega

but in this course where big O is written it usually mean big Θ 13m - thanks for the confusion

31m 1d Peak finding - running timeT(n)
WRITE OUT - in hand written notes L1

43m 2d Peak finding - running timeT(n)
WRITE OUT - in hand written notes L1

Finish R1 notes from - Recurrence Traps & 2-D Peak Finding: Algorithm 5


#### Maths notes  
(26m) [Stirlings approximation - equation for n!](https://en.wikipedia.org/wiki/Stirling%27s_approximation)  
$$
\begin{equation}
  n! \approx \sqrt{2 \pi n}\left(\frac{n}{e}\right)^n
\end{equation}
$$
(26m) [Equation for Series - summation](https://en.wikipedia.org/wiki/Stirling%27s_approximation)  
$$
\begin{equation}
  \sum_{i=1}^{n}i = \frac{n(n+1)}{2}
\end{equation}
$$


### L2 - Models of computation, Python cost model, document distance	   
[vid](https://www.youtube.com/watch?v=Zc54gFhdpLA&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=2) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec02.pdf) ~ 
DocDistance 8 versions Code see R2 ~ 
[DocDistance 8 versions R2 notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec02.pdf)  

#### Vid contents
0-6m - Whats an algorithm  
6m - model of computation  
7m50 - Random access machine (model of computation)  
13m40 - Pointer machine (model of computation)  
19m - 32m - Python model
32m -  44m - Document distance
44m - 8 version of doc distance and optimisations


Algorithm: computational procedure for solving a problem  
What is time (complexity)? **O(1) = constant time**  

#### Model of computation:  
Operations an algorithm can perform  
Time cost of those operations  
Models of computation:  
a) random access machine RAM - word array  
	- load O(1)  
	- compute O(1)  
	- store O(1)  
	- word log(size of memory)  
b) pointer machine (OO programming)  
	- dynamically allocated objects O(1)  
	- object has constant no of fields O(1)  
	- word or pointer / references / null or None O(1)  

#### Python Model  - Computational Steps  

Increment array item:  
	list[i] = list[i] + 5    is **O(1)**  

Object attribute access:  
	obj w/ O(1) number of attributes (constant no. of attributes)  
	attribute access is **O(1)** - pointer/ref access  

Access next item in linked list:  
	x = x.next is **O(1)**  

Add item to linked list:  
	list.append(x) ? python uses table doubling **O(1)**  

Adding two linked lists together  
	list1 + list2  **O(n)**  
	Code steps:  
	L = []	 O(1)  
	for x in list1: L.append(x) O( len(list1) )     - for list L - len(L) also written | L |  
	for x in list2: L.append(x) O( len(list2) )     - len, length, size, no of elements  
	total:  **O(1 + len(list1) + len(list2) ) = O(n) **  

Checking existence of item in list:  
	x in L  **O(n)** - linear time  
		from python check to see if x is in list L  
		required search through whole list (worst case)  

Sorting a list:  
	L.sort()   **O(| L | log | L |)**					- ie **O(n log n)**  
	Covered [Lecture 3	Insertion sort, merge sort](#3insertion-sort-merge-sort)  

Retrieving item from hash w/ key:  
	retrieve dict[key]	  **O(1)** constant time (uses lookup hash)  
	Covered in [Lectures 8-10 Hashing with chaining](#8hashing-with-chaining)  

Adding two longs (many word numbers)  
	add two number of x words & y words:  
	x+y    **O(|x| + |y|)**  
	x*y    **O((|x| + |y|)^lg3)**  
	NOTE lg  used instead of log base 2 (log_2)  
	lg3 = 1.6 so better than quadratic time  
  	Covered in [Lecture 11 - Integer arithmetic, Karatsuba multiplication](#11integer-arithmetic-karatsuba-multiplication)  

**heapq** covered in lecture [4 - Heaps and heap sort](#4heaps-and-heap-sort)  

#### Document distance (problem and algorithms)  
d(D1, D2)  like a correlation function, similarity of two documents

The idea is to look for shared words:  
Start by creating the vector of a document, hash of words (key = word) with a count of each one as value.  
Create a vector common words, it contains only the word in both doc vectors  
Sum them up to give a value.  
The larger the value the more correlated they are.  
Obviously bigger documents will naturally give bigger numbers do the value is normalised by dividing by the size of the original vectors.  

$$
\begin{equation}
  D_1.D_2\\
\end{equation}
\begin{equation}
  \sum_{w}D_1[w].D_2[w]
  \label{sum}  
\end{equation}
$$

#### Examples Document distance code:
[this repo](https://github.com/UnacceptableBehaviour/algorithms/tree/master/lecture_code/L2_doc_distance) 
or [on web](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lec02_code.zip)  

#### Maths notes  
41m angle of two vectors  
more detail? 

REFS  
[Time Complexity of Common Data Structures](https://www.bigocheatsheet.com/)  
[Look into this Latex insertion solution](https://stackoverflow.com/questions/35498525/latex-rendering-in-readme-md-on-github)  
[using pdfLatex may work](https://tex.stackexchange.com/questions/885/how-can-i-use-latex-from-python)  
Or use LaTeXiT from the command line to parse and auto generate equations  
Or [readme2tex](https://github.com/leegao/readme2tex)  



### R2 - doc distance optimisation - python cost model
[vid](https://www.youtube.com/watch?v=j0upQLUrpM8) ~ 
[lect notes - CODE handout](https://courses.csail.mit.edu/6.006/fall11/rec/rec02_code_handout.pdf) ~ 
[python cost model 8 sources compared](https://courses.csail.mit.edu/6.006/fall11/rec/rec02.pdf) ~ 
[Doc Distance 7 stages optimisation local code](https://github.com/UnacceptableBehaviour/algorithms/tree/master/lecture_code/L2_doc_distance) ~ 
[Code - PSet 1](https://github.com/UnacceptableBehaviour/algorithms/tree/master/problems/MIT6_006F11_ps1)  

#### Vid contents
0-7m - inner product  
7m - got through docdist1  
13m - cost of code by line - docdist1: get_words_from_string() - [CODE handout](https://courses.csail.mit.edu/6.006/fall11/rec/rec02_code_handout.pdf)  
 One line, N = characters, w = word size, number of word = N / w + 1 (1 for each space)  
 



#### Setting up for profiling
```
```

#### Code of code
```
9
10
11
12
13
14 
```

#### Comparing versions
Compare dd1 vs dd2
optimisation 


#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  






- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Problem set 1.
[PDF here](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf)  




### Problem 1-1. [15 points] Asymptotic Practice   Calculating asymptotic complexity (Big O notation)  
For each group of functions, sort the functions in increasing order of asymptotic (big-O) complexity:  
Order of complexity here [**Time Complexity - Order Severity**](#time-complexity--order-severity)  
Plotting functions to get a feel for them [./matplotlib/time_complexity_plot_q.py](https://github.com/UnacceptableBehaviour/algorithms/blob/master/matplotlib/time_complexity_plot_q.py)   
Comment functions in/out of the source or add custom functions!   

Problem 1.1a
$$
\begin{align}
f2(n) = 10000000n = O(n) = linear\\
f1(n) = n^{0.999999}log n = O(n log n) = quasilinear \\
f4(n) = n^2 = O(n^2) = quadratic\\
f3(n) = 1.000001^n = O(c^n) = exponential
\end{align}
$$

Problem 1.1b
$$
\begin{align}
f1(n) = 2^{2^{1000000}} = O(1) = constant\\
f3(n) = \binom{n}{2} \text{ notation is combinatorics} = O(nlogn)\\ 
f4(n) = n \sqrt{n} = n^1{n^\frac{1}{2}} = n^{1.5} = O(n^c) = polynomial\\
f2(n) = 2^{2100000n} = O(c^n) = exponential
\end{align}
$$
Note for f3() boils down to this [proof I think . . ](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/1st_stab_nCr_proof.jpeg)  
\begin{equation}
    log(n^{n+\frac{1}{2}}) - log((n-2)^{n-\frac{2}{3}}) =     (n+\frac{1}{2})log(n) - (n-\frac{2}{3})log(n-2)
\end{equation}
with the left dominating the right give nlog(n)  


Problem 1.1c  
$$
\begin{align}
f2(n) = 2^n = O(c^n) = constant.exponential\\
f4(n) = \sum_{i=1}^{n}(i+1) = \frac{n(n+1)}{2} = O(n^2) = quadratic\\
f1(n) = n^{\sqrt{n}} = n^{n^{\frac{1}{2}}} = O(n^n) = linear.exponential\\
f3(n) = n^{10}.2^{\frac{n}{2}} = O(n^c.c^n) = polynomial.exponential\\
\end{align}
$$

### Problem 1-2. [15 points] Recurrence Relation Resolution
For each of the following recurrence relations, pick the correct asymptotic runtime:  
asymptotic complexity of an algorithm with runtime T (n, n)  
(a)  
(b)  
(c)  
Maths course: 

[Lots of resources for recurrence relations]()

### Problem 1-3. [16 points] Peak-Finding Correctness 
Double click /problems/MIT6_006F11_ps1/visualizer.html to see algorithms in operation.  
Python code notes:  
Its python2 so run with  
```
> cd /algorithms/problems/MIT6_006F11_ps1				# source unzip directory
> python ./main.py 
Enter a file name to load from (default: problem.py): 
Algorithm 1 : (4, 4) => is a peak
Algorithm 2 : (4, 4) => is a peak
Algorithm 3 : (4, 4) => is a peak
Algorithm 4 : (4, 4) => is a peak
```

OK so whats going on here?  
```
main.py
	load problem(matrix) from problem.py(or pas file name via CLI arg)
	create list of algos, tuples of (name, algo_no_func)
	iterate through list and call each algo w problem, trace
		trace object is a list of dictionaries, each method appends a result of each step in the algorithm as a dict
		the list of dicts is coverted into json file (trace.jsonp) 
	print results

Once run the results can be visualised with visualizer.html which loads data created by the tracer (in trace.jsonp)
	json file loaded by visualiser: <script type="text/javascript" src="./trace.jsonp"></script>	
```
Asses each algorithm to see if it is correct, and if it is efficient:  
a)  algo 1 correct? r x c    
  p1 (4,4) yes  
  p2 (2,7) yes  
  p3 (3,5) no - 11 surrounded by 3 11s finds peak right there  
  p4 (3,4) yes    
  p5 (3,8) no - stops on consecutive same values
  
     efficient?   
b) algo 2 correct? r x c  
  p1 (4,4) yes  
  p2 (4,3) no - stops on consecutive same values - CHANGE TEST   
  p3 (4,3) no - stops on consecutive same values - CHANGE TEST     
  p4 (4,4) yes    
  p5 (4,5) no - 
  

     efficient?   
c) algo 3 correct? r x c     
  p1 (4,4) yes  
  p2 (5,4) no - goes left - stops on consecutive same values - CHANGE? TEST - recursion required    
  p3 (6,5) no - stops on consecutive same values - > test
  p4 (4,4) yes    
  p5 (5,8) no - 
  

     efficient?   
d) algo4 correct? r x c     
  p1 (4,4) yes  
  p2 (5,4) no - goes left - stops on consecutive same values - CHANGE? TEST - recursion required
  p3 (6,5) no - stops on consecutive same values - > test
  p4 (4,4) yes    
  p5 (5,8) no - 
     efficient?   
 
e) algo 5 brute force scan - CORRECT
  p1 (4,4) yes  
  p2 (2,7) yes  
  p3 (4,6) yes  
  p4 (4,4) yes    
  p5 (6,6) yes    





### Problem 1-4. [16 points] Peak-Finding Efficiency 
	Look at 4 alorithms in algorithms.py 
	Assess correctness, efficiency
### Problem 1-5. [19 points] Peak-Finding Proof 
	proof for one of the algorithms
### Problem 1-6. [19 points] Peak-Finding Counterexamples 	data that shows how the python algorithms can fail

REFERENCES:
[Correctness - various proofs](https://www.youtube.com/user/intrigano/search?query=correctness)  
[Reccurence relation by Induction](https://www.youtube.com/watch?v=t_3ACuzEe_8)  




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 2: Sorting and Trees
### L3 - Insertion sort, merge sort
[vid](https://www.youtube.com/watch?v=Kg4bqzAqRBM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=3)
[recitation]()  
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec03.pdf)  

#### Insertion sort
Sorted list have various properties:   
	simple to find median (constant time)  
	find item:  
		scan to find O(n) in sorted & unsorted list  
		binary search O(log n) (halves the list at each step)

Application: compression (frequency counting), graphic z-order etc

Insertion sort - also in doc distance python files (/algorithms/lecture_code/L2_doc_distance)

**Bubble sort** (scan list swap values in the wrong order, repeat) O(n^2)  

**Insertion Sort**  
a) Vanilla insertion sort (L2_doc_distance)  
Move 1st item to new list, move next item to new list **scan** until correct place found, insert, repeat  
**n^2** - breaks down as: (n for number of items) * (n for search & insert )

b) Binary insertion sort  
Move 1st item to new list, move next item to new list **binary search** until correct place found, insert, repeat  
**n log n** - breaks down as: (n for number of items) *  (log n for binary search & insert )

#### Merge Sort  
[Merge sort in 3mins](https://www.youtube.com/watch?v=4VqmGXwpLqc)  
Pseudocode: (@ 2m32 in above link)
Split array into 2,  
repeat until only 2 items in each leaf,  
sort those two items,  
go up a layer and merge leaves   

[Python implementation here] (https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/merge_sort.py) likely naive.  

**Concept of auxiliary space**, in the above python code that would be stack I assume.


Instrument the merge sort code - s

[Difference between theta, omega complexity and big O](https://www.youtube.com/watch?v=6Ol2JbwoJp0)  
  

		Problem set 2 out - Event simulation

### L4 - Heaps and heap sort  
[vid](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-4-heaps-and-heap-sort)
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec04.pdf)  
Reading: none listed  
Code: [Python](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/heap_ify.py)  


#### **DATA STRUCTURE - Priority Q - L4 3m33**  
**type**:  -  (maxheap or minheap) - prefered implementation ?  
**use cases**: finding min or max value in sorted set (not both), scheduling, flattening linked list, finding non overlaping intervals, ROAM  
**queries**: min/max  
**updates**: pop_min/max - Θ(logn), insert item - Θ(logn), delete item - Θ(logn), change priority  
**RI max heap**: Node is larger than or equal child nodes, complete binary tree  
**RI min heap**: Node is less than or equal child nodes, complete binary tree  
**properties**: root contains max/min value, comparison model  
node positions in array:  
root i=1  
parent = i/2  
lc_i = 2i  
rc_i = 2i+1     
![array implementation allocation](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/Heap-as-array.svg.png)  
Credit: https://en.wikipedia.org/wiki/Heap_(data_structure)#/media/File:Heap-as-array.svg  
RI - representation invariant  



#### Priority Queue
Implements a set of elements associated with a key - methods:
insert(x, into set S),  
get max priority (of set S),  
extract_max (of set S)  -  get max and remove it!  
inc_key (in set S, increase element xs key, to value k)  
get min priority (of set S),  
delete, change priority in Q.  

#### Heap
Is an implementation of a priority Q, array structure visualised as a nearly complete binary tree - p4  

Root of tree is array index 0, (tree node i=1)  
1,2 are LEFT & RIGHT split  
3,4 - 5,6 are next layer LEFT & RIGHT split  
counting on like that [see page 4](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec04.pdf)  

##### Heap as a tree navigation
[see page 5](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-4-heaps-and-heap-sort)  
**Using array to implement the heap**  
root i=1  
parent = i/2  
left = 2i  
right = 2i+1  

No pointers required.

##### Heap as a tree properties
**Max heap property:**  
the key of a node >=  keys of its children  
(the key being the value in the circle)  

**Min heap property:**  
the key of a node <=  keys of its parent  

##### Max_heapify  
[Python source exercise here](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/heap_ify.py)

Note for array of **any** size: element A[n/2+1 . . n] are ALL leaves!





### L5 - Binary search trees, BST sort	 
[vid](https://www.youtube.com/watch?v=9Jry5-82I68&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=5) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec05.pdf) ~ 
[Code 1st guess](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/binary_search_tree.py) ~ 
[Code MIT](https://github.com/UnacceptableBehaviour/algorithms/blob/master/lecture_code/L6_BST_AVL_trees/bst.py) ~ 
Reading: CLRS Chapter 10, 12.1-3

#### **DATA STRUCTURE - BST - Binary search trees**  
**type**: BST  - [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree)  
**use cases**: sorted data, priority queue 
**queries**: next_smaller, next_larger, search/find, min, max, node_count_before  
**updates**: insert, delete  
**representation invariant (RI)**: ALL children to left are smaller, ALL children to the right are larger.  
**properties**: sorted data, comparison model  
See [R5 - Recursion Trees, Binary Search Trees](#r5---recursion-trees-binary-search-trees) for queries / updates walkthrough

#### Vid contents
0-6m	define problem - runway scheduling - to demonstrate BST ADT  
6m-21m	EGs things that dont work: sorted array, sorted list(no fast insertion), heap(no successor/ predecessor or pointers)  
21m	intro to BSTs  
24m	BST RI  
26m	insert() - O(h) - height of tree - **O(logn)** - n=number of nodes  
35m	min() - O(h) - go farthest left   
36m	max() - O(h) - go farthest right  
37m-43	Functional **AUGMENTATION** - Rank(t) - how many planes land before time t?   
              Add number of nodes below node to it. (number includes node itself)  
43m	AUGMENTATION - Rank(k) - algorithm code - O(logn) for a balanced tree!! Pseudo code below.   



Concept: Representation Invariant - property of the data structure  
Invariant (RI): All children to left are smaller, all children to the right are larger.  
Each node has 3 pointers: parent, lchild, rchild  
```
      x
     / \
   <x   >x
```

Runway scheduling problem. Insert aircraft landing  at least k minutes (3 min in this case) away from any other scheduled landings.  
Plane landing @:	2  5  37  44  99  
**Steps**  
Find position  
Check if theres 3min space either side  
Insert new landing  

Implemented as **sorted array**  
Find insertion point: use binary search - O(logn)  logarithmic time  
Check space to land (3minutes) - O(1) constant time  
Insert (requires shifting each element to make space for insertion - worst case front of array) O(n) - linear time  

Implemented as **sorted (linked) list**  
Insert is pointer manipulation - O(1) constant time - better  
No binary search on a list! - so brute force O(n)  

Implemented as **heap**  
Check for element n1 <= k <= n2 requires searching whole tree - O(n)  

Implemented as **binary search tree (BST)**  
Find, navigate tree left if looking for an earlier time, right if larger. worst case from root of tree to leaf - ie height O(h)  
Check do check at each node O(1)  
Insert pointer manipulation O(1)  

**Other O(h) operations**  
Min - far left leaf  
Max - far right leaf  
Next largest value - Up a node? NO its next right node - parent.min() - smallest node of parent subtree. (or parent if no subtree)  

#### Augmented BST - 37m - node_count_before - RANK  
Augmented BST add subtree size to the data in the node. Includes the node and its children (number after dash in tree below).    
Maintained by incrementing the tree size by one as theyre traversed to an insertion.  

To find how many planes scheduled to land before time t?  
Find highest node that is smaller than t return tree size to the left of the node including it.  
Which is node subtree size - right_child subtree size (since all these nodes are higher) - **ALMOST**  
To the left of the tree including back up the tree! Work through example!    

```
                    129-12

        104-5                   158-6

   82-3       116-1     **138-3       184-2    

77-1 103-1  -     -    134-1 141-1 175-1  -   
```

For t=138 number planes scheduled before are - 43m  
All of left subtree: left_child.tree_size = 1  
plus  
(find first **parent** node less than 138) = 129.left_child.tree_size + 1(node 129) = 6  
gives  
total: 7  

**Algorithm:**
```
Start at root is **t** larger than node?  
YES - add left_child.tree_size + 1 to total, move to right_child  
NO - move to left_child  
Repeat until no more children or t = node  
Return total  
```

### R5 - Recursion Trees, Binary Search Trees
[vid](https://www.youtube.com/watch?v=r5pXu1PAUkI&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=28) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec05.pdf) ~ 
[Code 1st guess](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/binary_search_tree.py) ~ 
[Code MIT](https://github.com/UnacceptableBehaviour/algorithms/blob/master/lecture_code/L6_BST_AVL_trees/bst.py) ~ 

#### Vid contents
3m-14m 	Solving Recurrence for merge sort. (PS2 problem 1)
14m-26m	Data structures, HEAP
26m-35m	Data structures, BST, (unbalanced)
35m-42m 	BST find successor/predecessor
42m-54m 	BST delete, 3 cases O(h) height of tree
54m-end	BST augmentation - Uses example min - needed for problem set 3 PS3

#### Maths notes  
Solving Recurrence for merge sort:
```
def merge_sort(unsorted_array)						# n elements
    bisect unsorted_array into aL & aR
	while aL elements > 1: left = merge_sort(aL)	# keep going if more than one element
	while aR elements > 1: right = merge_sort(aR)	
	return merge(left, right)						# nulls removed in merge
```

1st term: merge_sort calls itself twice with n/2 elements 2T(n/2)
2nd term: merge take O(n)? but n=1 in final node so O(1) constant time

T(n) = 2T(n/2) + O(n)             # recurrence
T(1) = Θ(1)                       # base case - merge (1 element)

```
merge_sort call with number of elements
              n
       n/2            n/2
  n/4      n/4    n/4      n/4             # each recursion
	|
until reach base case
	|
1   1   1   1  . . .  1   1   1   1        # base case
```


Binary Search Tree (BST) 
Local: algos/binary_search_tree.py


#### get_successor()
```
Example tree
                                               67                                               

                       45                                             129                       

           15                      57                     104                     158           

     -           29          -           66          82         116         138         184     

  -     -     17    35    -     -     -     -     77   103    -     -    134   141   175    -   

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  90 -  -  -  -  -  -  -  -  -  -  -  -  - 
rc = right_child   rp = right_parent(node == node.parent.left)

# case 1 - node has rc
return rc.min


# case 2 - node has no rc (dont care about lc always smaller)
         - has rp (left of parent : node == node.parent.left)
return parent


# case 3 - node has no rc or rp
         - right of parent : node == node.parent.right
go up parent until one has a right parent
return that

Case 3 covers case two - so no need to implement case 2
```

#### delete()
```
Example tree - BST (Binary search tree - unusually flat! Can be very lopsided)
                                               67                                               

                       45                                             129                       

           15                      57                     104                     158           

     -           29          -           66          82         116         138         184     

  -     -     17    35    -     -     -     -     77   103    -     -    134   141   175    -   

 -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  90 -  -  -  -  -  -  -  -  -  -  -  -  - 
rc = right_child   rp = right_parent(node == node.parent.left)

case 1: leaf
	simply delete

case 2: delete single node with only one sub-tree
	EG delete 15, 57 or 184
	replace parent pointer to node to point at subtree
	straight or zig/zag its the same

case 2: deleting a node that has 2 subtrees
	replace node with successor - smallest element in right subtree
	successor may have a subtree so need to call delete on it first
	replace original deleted node with it
	(from R5-44m50)


	running time 
		find key O(h) +
		delete - possible 2 subtrees O(h)
		link swaps constant time O(1)
		= O(h) + O(h) + O(1) = 2 * O(h) + O(1) = O(h)

```



### L6 - AVL trees, AVL sort	
[vid](https://www.youtube.com/watch?v=FNeL18KsWPc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=6) - 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec06.pdf) - 
[MIT EG code](https://github.com/UnacceptableBehaviour/algorithms/blob/master/lecture_code/L6_BST_AVL_trees/avl.py) - 
[guess implementation code](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/AVL.py)  
 

#### **DATA STRUCTURE - AVL tree - R6 50m**  
**type**:  tree (balanced )  
**use cases**: sort & retrieve data set, prefered in search intensive application, insert more costly  
**queries**: min, max, successor, predecessor, search - Θ(logn), in-order traversal - Θ(n)  
**updates**: insert item - Θ(logn), insert n items - Θ(nlogn), delete item - Θ(logn), rebalance    
**RI**: height left/right trees only every differ by 1 - balanced tree   
**RI from BST**: ALL children to left are smaller, ALL children to the right are larger.  
**properties**: height = logn => tree balanced - height & balance maintained in each node, comparison model   
RI - representation invariant  

#### Vid contents  
0-2m - BST summary - in-order traversal using recursion  
2m-11m - importance of being balanced -  getting HEIGHT to be logn - local HEIGHT calculation  
11m - AVL trees definition and balance  
18m - showing height is logn  
10-28m - height of balanced tree maths  
19m-25m - Analyse Nh min nodes in a tree of height h - v1  
26m-XXm - Analyse Nh min nodes in a tree of height h - v2 - ps3  
32m-48m -  Rotations  
48m-52  - AVL sort  
50m - summary of heap / bst AVL reasons for use  

#### Example problem


#### TERMS  
AVL - inventors Adelson-Velsky and Landis   
[Visualisation of AVL tree](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)  

**In order traversal** - process nodes by key order  
**successor** - Next larger  
**predecessor** - next smaller  
**height** of a node - longest path down to a leaf from node  including itself (the +1 below)  
**depth** of a node - node in path from root to node
**balanced** tree - height of left child = height of right child  +/-1 - height h = **logn**

IMPORTANCE OF A BALANCED TREE - height being log n   
Unbalance tree worst case height - n average n/2  << V.BAD!  

```
height  = max(lchild height, rchild height) +1  max(3,8)+1 = 9  (maintained in each node)  
```

NOTE:  NULL child node have a height of -1 so cal works - max(-1,-1)+1 = 0  
information local to node has low (constant time) maintenance over head   
largest_height also store which height is larger +1 left,  0 equal, -1 right


#### Maths notes - AVL tree (19-25m) - height analysis v1
Min number of nodes in a balanced tree

![Total nodes in AVL tree](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/L6_AVL_trees_00_22m33.png)  

$$
\begin{equation}
  N_h = minimum\;number\;of\;nodes\;in\;an\;AVL\;tree\;of\;height\;h
\end{equation}
\begin{equation}
  N_{O(1)} = O(1)\;\;base\;case
\end{equation}
\begin{equation}
  N_h = 1 + N_{h-1} + N_{h-2}
\end{equation}
$$

IE In a tree of height h, number of nodes n,  is the sum of: the root + the two sub trees (that differ in height by 1).   

The above recurrence is similar to the Fibonacci sequence, defined as:
\begin{equation}
  F_h = F_{h-1} + F_{h-2}
\end{equation}

an approximation for which is  (Fibonacci number = nearest integer . . .
\begin{equation}
  F_h =  \frac{\phi^h}{\sqrt5},\; h \ge 0,\; (phi)\;\phi=\frac{1+\sqrt5}{2},\;\phi\approx1.618
\end{equation}

[paper showing the above here](https://sites.math.northwestern.edu/~mlerma/problem_solving/results/recurrences.pdf)  

\begin{equation}
  N_h > \frac{\phi^h}{\sqrt5},\;\;  N_h > \frac{1.618^h}{\sqrt5},\;\; n > \frac{1.618^h}{\sqrt5}
\end{equation}

Since Nh = min nodes in a tree of height h, and phi = 1.618.

\begin{equation}
  n > \frac{\phi^h}{\sqrt5}\;same\;as\;\frac{\phi^h}{\sqrt5} < n\;\; take\; log_{\phi}
\end{equation}
\begin{equation}
  h + sml\;const < log_{\phi}n \approx 1.44log_2n
\end{equation}

#### Maths notes - AVL tree (26m) - height analysis v2





Method of maintaining property: balanced AVL tree.  << WHOLE LECTURE ABOUT THIS!

**insert(x)** - steps to do an insert
```
insert as normal for BST
update each nodes height while parsing tree (and largest_height L M R - left middle right)
largest_height = hL - hR 
from inserted node walk up the tree checking largest_height if abs(largest_height) > 2
	if largest_height > 2 right-rotate	(left height too large)
	if largest_height < -2 anti-rotate	(right height too large)
```

What the above is saying is - if the difference in height between to children is more than +/-1 then tree need rebalancing
	
Rotation Cases (@ 32m)
```
      29
     /
   26
  /
23              # left height too large 
      
   26           # right-rotate 29
  /  \
23    29
```
2nd case
```
      65
     /
   50
     \
      55        # zig zag requires 2 rotations:
					
      65        # left-rotate 50
     /
   55
  /
50              # right-rotate 65:

   55
  /  \
50    65

```



50m good summary of heap / bst AVL reasons for use



### R6 - AVL trees
[vid](https://www.youtube.com/watch?v=IWzYoXKaRIc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=29) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec06.pdf) ~ 
[Code Handout](https://courses.csail.mit.edu/6.006/fall11/rec/rec06_code_handout.pdf) ~ 
Reading: 

#### Vid contents
0-7m - BST review, height  
7m-11m  AVL balance  
11m	  Why height is logn (number of nodes in h rows (doubles each row) n = 2^h so height h = logn)  
18m BST review, insert  
21m AVL review, left_rotate, right_rotate  
28m22 pointer exchange pseudo code right_rotate  
40m AVL review REBALANCE  
50m rebalance synopsis - AUGMENTATION (height in this case) needed for ps3  

#### BST review
height h = longest path to leaf  

**4m28** - diagram on board show a single node has a height of 0  
then he writes  
```
height  = max(lchild height, rchild height) +1  max(3,8)+1 = 9  (maintained in each node)  
```
which means tit should be 1 - ??   
The code line - Height Augmentation ln 7 says 1  
```
def update_height(node): 8 node.height = max(height(node.left), height(node.right)) + 1
```
**6m** for case where node is a leaf height returns -1!  
so the root evaluates to max(-1,-1)+1 = 0  

#### AVL properties
\begin{align*}
  h = max(h_l, h_r) + 1 \\
  h = -1\;for\;leaf\;node \\
  \forall n, |h_l - h_r| \le 1 \\
  plus\;BST\;properties
\end{align*}
\begin{align*}
  h = height\;of\;node \\
  h_l = height\;of\;left\;child \\
  h_r = \textit{height of right child} \\
\end{align*}

Reads **for all** n, height of left and right subtree differs by 1 or less - basically says this tree is **balanced**
\begin{align*}
  balanced\;property:\\
  \forall n, |h_l - h_r| \le 1
\end{align*}

REBALANCE
CASE 1 - unbalanced in a straight line: Rotate to fold the line


#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  
  

### L7 - Counting sort, radix sort, lower bounds for sorting and searching
[vid](https://www.youtube.com/watch?v=Nz1KZXbghj8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=8&t=0s) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec07.pdf) ~ 
[radix_sort](https://www.youtube.com/watch?v=kPRA0W1kECg) MSB 1m56 - LSB 2m11
Code:
Reading: 

#### **DATA STRUCTURE - Counting sort**  
**type**: , mediocre sorting algorithm 
**comp model**: non comparative, ram model, sorting algorithm  
**use cases**: good for bla  
**queries**:  
**updates**: sort O(k + n)  n=num of keys, k=key range (32 for a 5it key)  
**(RI)**:   
**properties**: in place? stable  
comp model = computational model

#### **DATA STRUCTURE - Radix sort**  
**type**:  (bucket / digital sort), sort by digit LSB > MSB or vice versa, based on counting sort, stable  
**comp model**: non comparative, ram model, sorting algorithm  
**use cases**: good for bla  
**queries**:  
**updates**: sort O(d + n)  n=num of keys,  d=digits in key  
**(RI)**:   
**properties**: in place? stable  
comp model = computational model




#### **Vid contents**  
0-2m - Introduction  
2m-32m Computational models - **Comparison model**  
5m20 - Descision tree  
14m48 - properties of descision tree - node, leaf, path, path length, height  
16m - Searching lower bound  
18m - PROOF searching Ω(lg n) - simple  
20m-24m - Sorting lower bound - logic
24m-32m - Sorting lower bound - maths PROOF - p2 in notes  
32m-37m - INTRODUCTION RAM MODEL & INTEGER SORTING  
37m-40m - COUNTING SORT  
40m-44m - Counting sort RUNNING TIME - O(k + n)  n=keys k=key range - no of digits? 
45m - [RADIX Sort](https://www.youtube.com/watch?v=kPRA0W1kECg) MSB 1m56 - LSB 2m11 
[RADIX sort wiki](https://en.wikipedia.org/wiki/Radix_sort)  


#### Sorting in Linear-Time  
- **comparison model**   (computation model)  
- Only operation allowed are comparisons
- lower bounds  
	searching: Ω(lg n) - binary search is optimal  
	sorting: Ω(n lg n) - merge sort is optimal  

CONCEPTS: Models of computation: **Comparison model** 2-32m  
| decision tree | algorithm |
|-|-|
| internal node | binary decision (comparison) |
| leaf | answer |
| root-to-leaf path | algorithm execution |
| path length | running time |
| height of tree | worst case running time |


- **ram model**   (computation model)  
- O(n) sorting algorithms  
. . counting sort  
. . radix sort  

**Assumptions**:
\begin{align*}
  sorting \\
  n\; keys\;\in\{0,1,2,..k-1\} \\
  \text{and each fits in a word} \\
  \text{for k...large number?} \\
  \text{can be sorted in }\Theta(n)\; time
\end{align*}

##### Counting Sort - 37m
Go through unsorted items using key to allocate to an index of an array.
This basically creates a **linked list** at the **index** of an array for **duplicates**

Running cost: O(k + n)  n=number of keys, k=key range (5bits key this is 32?)

##### Radix Sort - 45m
Conceptually simple - sort by each digit starting from LSB or MSB 



### R7 - Algos so far summary - 
[vid](https://www.youtube.com/watch?v=9bkvws_vqLU&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=30) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec07.pdf) ~ 
Code:
Reading: 

#### Vid contents
0-  - Summary sorting Algos so far  
7m - Python comparison overloading __lt__,__le__,__gt__,__ge__,__gq__,__ne__,
7m-35m - implementing COUNTING sort in place?
35m - implementing RADIX sort
42m-47m - RADIX sort running time justification - REDO this when awake - ps2 or ps3
47m-52m - Stability, implications & summary of algos

#### Summary Sorting Algos So far:
Note for sorting you have to output the data set size n for optimal run time(Ω) is Ω(n)

| algorithm | running time | model | stability |
| - | - | - | - |
| insertion sort | O(n^2) | comparison model | stable |
| merge sort | O(n.logn) | comparison model | stable |
| heap sort | O(n.logn) | comparison model | unstable |
| counting sort |  O(k + n) | ? model | stable |
| radix sort | - | O(d + n) | stable |
| - | - |

Notes
**Comparison model** (only using comparisons) SORTING run time **Ω(n.logn)**
counting sort k=digits

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 	
## Problem set 2.
[PDF here](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps2.pdf)  

#### 2-1 Fractal rendering [40pts]
Koch snowflake rendering: computational requirements of 4 ways of rendering LoD n (Level of Detail 0-n)  
	Recitation 5 (0m - 13m) explains how to do this - dont be scared if you costs at each level arent the same sum them up and youll get the right answer  
	Recursion tree - forrest of trees in this case  
	Run example code fractal.html (/algorithms/problems/MIT6_006F11_ps2/fractal)  git difftool
  
**First - 3D hardware accelerated rendering . .**  
Surface > triangles > CPU co-ords list > GPU renders  
a) [1pt] height of recursion tree for rendering snowflake of LoD n?  
b) [1pt] how many node in the tree at level n  
c) [1pt] whats the rendering time (triangle count) for a node at depth i  
d) [1pt] whats the rendering time (triangle count) at each level i (all nodes on that level)  
e) [1pt] total asymptotic cost for the CPU to render LoD n (using this method)  
  
**Second - 2D accelerated rendering . .**  
Surface oulines > open/closed paths > CPU co-ords list > GPU renders (used in laser cutters & plotters)  
Properties of a koch snowflake   
f) [1pt] height of recursion tree for rendering snowflake of LoD n?  
g) [1pt] how many node in the tree at level n  
h) [1pt] whats the rendering time (line segment count) for a node at depth i  
i) [1pt] whats the asymptotic rendering time (line segment count) for a node in the last level n  
j) [1pt] whats asymptotic rendering time (line segment count) at each level of the tree  
k) [1pt] whats the asymptotic rendering time (line segment count) at the last level n	
l) [1pt] total asymptotic cost for the CPU to render LoD n (using this method)  

**Third - 2D unaccelerated rendering . . aka software rendering (CPU only)** (used in laser cutters & plotters)  
Surface oulines > open/closed paths > CPU co-ords list > CPU rasterises co-ords   
NOTE the rasterised pixels represent the ink required to print or the the power required for laser to cut the image!!  
m) [1pt] height of recursion tree for rendering snowflake of LoD n?  
n) [1pt] how many node in the tree at level n  
o) [1pt] whats the rendering time (line segment length) for a node at depth i (assume original triangle side length = 1)  
p) [1pt] whats the asymptotic rendering time (line segment length) for a node in the last level n  
q) [1pt] whats asymptotic rendering time (line segment length) at each level of the tree  
r) [1pt] whats the asymptotic rendering time (line segment length) at the last level n	
s) [1pt] total asymptotic cost for the CPU to render LoD n (using this method)  
  
**Fourth - 3D unaccelerated rendering . . (CPU only)**  
Surface > triangles > CPU co-ords list > CPU rasterises  
t) [4pt] total asymptotic cost for the CPU to render LoD n (using this method - assume initial triangle side length = 1)  
u) [15pt] prove using recursion tree method  
  
#### 2-2 Digital Circuit Simulation [60pt]  

a) What name of method w highest CPU usage? _find_min part of class  

Profiler Qs
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     15/6    0.000    0.000    0.001    0.000 sre_parse.py:414(_parse)
Whats the 15/6 mean under ncalls? Recursive call here: 6 primitive call 15 in total

Profiler column meanings: https://docs.python.org/3/library/profile.html
```
ncalls
    for the number of calls.
tottime
    for the total time spent in the given function (and excluding time made in calls to sub-functions)
percall
    is the quotient of tottime divided by ncalls
cumtime
    is the cumulative time spent in this and all subfunctions (from invocation till exit). This figure is accurate even for recursive functions.
percall
    is the quotient of cumtime divided by primitive calls
filename:lineno(function)
    provides the respective data of each function
```

Full result of profiler in: circuit/profiler_output.txt
```
        628290079 function calls (628095620 primitive calls) in 474.045 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   259964  275.241    0.001  471.218    0.002 circuit.py:381(_find_min)         ** CULPRIT
625762426  195.969    0.000  195.969    0.000 circuit.py:286(__lt__)            # less than dunder function
    64400    0.788    0.000  473.659    0.007 circuit.py:423(step)		# simulation time step > _find_min > __lt__
828936/634537    0.264    0.000    0.340    0.000 {len}
    65554    0.233    0.000    0.421    0.000 circuit.py:163(transition_output)
   194381    0.216    0.000  471.437    0.002 circuit.py:361(min)
        1    0.173    0.173  473.948  473.948 circuit.py:456(run)
        1    0.001    0.001  474.045  474.045 circuit.py:3(<module>)
```

To run tests:
```
> python circuit_test.py                                               # whole suite - 6min

> python circuit.py  < tests/1gate.in > out                            # run single test write results out

> diff out tests/1gate.gold                                            # compare result to verified result

> python -m cProfile -s time circuit.py < tests/5devadas13.in          # profile test - take nearly 8min!

> TRACE=jsonp python circuit.py < tests/1gate.in > circuit.jsonp		# create a trace for visualiser
> TRACE=jsonp python circuit.py < tests/2gates.in > circuit.jsonp		# create a trace for visualiser
> TRACE=jsonp python circuit.py < tests/3xor.in > circuit.jsonp
> TRACE=jsonp python circuit.py < tests/4sort.in > circuit.jsonp

EG
> python circuit_test.py 
Testing correctness:
Testing 1gate.in ...... OK
Testing 2gates.in ...... OK
Testing 3xor.in ...... OK
Testing 4sort.in ...... OK
Testing 5devadas13.in ...... OK
.
----------------------------------------------------------------------
Ran 1 test in 360.847s
OK

> python circuit.py  < tests/1gate.in 
19 axb 1
29 axb 0

```

b) How many time is this method called? 259964
c) What tightest asymptotic bound of the worst case running time of the method with the bottleneck?
d) If implemented optimally whats the tightest asymptotic bound of the re-implemented method?
e) Re-write the data structure using the most efficient method from class (no lib imports)


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 3: Hashing
### L8 - Hashing with chaining - (dictionary / associative array)	 
[vid](https://www.youtube.com/watch?v=0M_kIqhwbFo&t=758s) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec08.pdf) ~ 
[succinct vid on hashing, open addressing & chaining](https://www.youtube.com/watch?v=KyUTuwz_b7Q) ~ 
[Code - 1st try - associative array](https://github.com/UnacceptableBehaviour/algorithms/blob/master/algos/assoc_array.py) ~ 
Reading: 

**#### Vid contents**  
0-5m - Into to dictionary & functions( insert, delete, search) - implement - O(1) constant time (w/ high probability)  
5m-13m - Python dict API summary, and Motivarion (see lect notes)  
13m-24m Solution 1 - Direct access table  
24m- Solution 2 - Hashing  
29n - introduces collisions - chaining  
34m - Simple uniform hashing - Mapping number of keys to number of slots   
42m - hashing to table size m
43m - DIVISION
44m - MULTIPLICATION


#### **DATA STRUCTURE**  
**type**: dictionary (ADT)  
**use cases**: dictionaries, dbs, compilers, symbol lookup, routers, virt mem, all over   
**queries**: search(key) O(1 + chain length = alpha)   
**updates**: insert(key, item), delete(key) both O(1 + chain length = alpha)     
**(RI)**:   
**properties**: m = Θ(n) ie number of spaces in table m ~ number of keys n    


**Motivation:**  
DB - uses hashing and search trees
Dictionary lookup - use hash table
Spell check - trial perturbation of each letter - really?


**13m Solution 1 - Direct access table**  
Problems:
1. key not being integers (therefore dont map direct to memory)  
2. if there are a lot of gaps in keys this solution is a huge memory hog!  

**Solution to 1:**  
Prehashing - map keys to integers (array location)  
  
Python built in hash() - should be called prehash - but basically return and integer based on the input. (to use as a key for dict for example)  
```
Python dunder function __hash__ is called when built in hash(object) is called.
if you dont implement hash hash(obj) used id(obj) to as the hash value
  this avoid collision because no two things occupy the same space in memory so id is unique
```
  
**24m Solution 2 - Hashing - Mapping from Giant space of key to array indexes**  
**Solution to 2:**  
I you have a space of keys, run those through hash function to generate indexes (ideally they should be equally distributed through the target array)  
The ratio of number of indexes (entries) (n) : number of array spaces (m)  is the load factor - alpha = n/m (aka expected collision chain length)  


Methods for dealing with collisions (Chaining @ 30m & open addressing (next week) ) one type of open addressing is linear probing

See L9 1m-4m sunccict synopsis of last lecture and this solution!!  
note the n may end up in a linked list for chaining  
![Visual summary of solution](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/_algos_6.006_L9_1m17.png)  
  
**Hashing methods: DIVISION, MULTIPLICATION, UNIVERSAL HASHING (prefered)**  
**34m - Simple uniform hashing - Mapping number of keys to number of slots**  
Assumptions:  
a) each key equally likely to be hashed to ANY slot in the table  
b) INDEPENDENT of where other keys hashing  
Hash function need to know size of table - m.  

**43m - DIVISION method**
\begin{align*}
  h(k) = k\;mod\;m
\end{align*}
Note: m should be PRIME and not too close to power of 2.  
  
**44m - MULTIPLICATION method - preferred over division (notes p5)**
\begin{align*}
  h(k) = [(a\cdot k)\;mod\;2^w] >> (w-r)\\
  k\;is\;w\;bits\\
  a\;is\;random\\
  where\;m=2^r\\
  \textit{m = array spaces}\\
  \textit{(expected collision chain length)}\;load\;factor\;\alpha=\frac{n}{m}\\
  \textit{expected operation (insert del etc) time}\;\Theta(1+\alpha)
\end{align*}
a should be random, odd, and in the range 2^(r-1) < a < 2^r, and NOT close to a power of 2.  
w number of bits in key range  
  
Basically multiply the key (w bits) by an odd (fixed to the function) random number resulting in a number of length 2w bits. (assuming a is also w bits long)
Take the section with the highest diversity (in the middle) that generates a number of at least m (required spaces). IE 2^r bits must be at least m 
Which is why the m=2^r part which select the length of th section that is taken for the hash result.
See diagram notes top   



**48m - UNIVERSAL HASHING (preferred)**  
blur. . . note bottom p6 . . . take 6.046 to understand better. . .
Revisit this - implementation seems relatively simple


**TERMS**  
prehash collisions  
collisions - chaining = storing the collision in a linked list at the address  
collisions - linear probing = store the collision in the next available free address  
collisions - open addressing = linear probing is open addressing (may not find item exactly where expected)  
collisions - closed addressing = chaining is closed addressing (item store always in same location)  
simple uniform hashing  
universal hashing  
  


### R8 - Simulation Algorithms
[vid](https://www.youtube.com/watch?v=eGSXsaJ-BlY&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=31) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec08.pdf) ~ 
[lect notes code](https://courses.csail.mit.edu/6.006/fall11/rec/rec08_code_handout.pdf) ~ 
Code: 
Reading: 

**#### Vid contents**  
0-xm - Walk the code in problem set 3 -  
9m - introduce lexicographic comparison sort  
17m-29m  - RangeIndex methods and running time for example (poor) code  
29m - KeyWirePairs,   
42m - RangeIndex - comparision model penalty  
43m - LIST LCA pseudo code  
49m - LCA run time intuition  



All the lines(vectors) are added to the RangeIndex
CrossVerifier((layers)._events_from_layer).wire_crossings > _compute_crossings > list 
	
7m
```
> python -m cProfile -s time circuit2.py < tests/10grid_s.in
file contains list wires: wire v7035 61240 -815340 61240 410695
                               name   x1     y1     x2    y2
                  vertical wire since x1 = x2
command[0]   wire 
command[1]   v7035 
coordinates  61240 -815340 61240 410695

Loaded into layers
layer = WireLayer.from_file(sys.stdin)          # ln
      if command[0] == 'wire':
        coordinates = [float(token) for token in command[2:6]]
        layer.add_wire(command[1], *coordinates)
              Wire(name, x1, y1, x2, y2) + internally enumerated wire_id
				x1, y1, x2, y2 = *coordinates
        layer.wires = dict with name as key, Wire object as value

Once loaded the layer is passed to CrossVerifier
_events_from_layer(layer)
    left_edge = min([wire.x1 for wire in layer.wires.values()])   # find leftmost co-ordinate
        
    go through wires and sort into events - add for horizontal, query for vertical
      if wire.is_horizontal():
        self.events.append([left_edge, 0, wire.object_id, 'add', wire])     # left_edge - constant
      else:
        self.events.append([wire.x1, 1, wire.object_id, 'query', wire])     # wire.x1 - wire dependant

    EG
    1) ADD [-100, 0, 1, add, wire_obj]         # horizontal wire - _events_from_layer:line 333
    2) QUERY [-50, 1, 2, query, wire_obj]      # vertical wire - _events_from_layer:line 333

    CrossVerifier.events is a list[]

self.events.sort() # sort by 1st column then second then 3rd if 1st column same
    So will sort:
    Horizontal vectors 1st (all have left_edge in 1st column) sorted by incrementing obj_id,
	then vertical vectors sorted by x.1 co-ordinate (left to right)
    
self.index = RangeIndex()                        # create RangeIndex
self.result_set = ResultSet()                    # create ResultSet

result = verifier.wire_crossings()
    self._compute_crossings(False)               # count_crossings calls self._compute_crossings(True)
        result = self.result_set                 # initialised as ResultSet()

       @loop through self.events                 # KeyWirePair - (KeyWirePairL & KeyWirePairH lower & upper limits obj_id)
       @                                         # have comparison operators __le__, __ge__ etc
       @                                         # add all the horizontal vectors as KeyWirePair objects
       @self.index.add(KeyWirePair(wire.y1, wire))	             the KEY in Range index is the horizonal lines vertical position y1
       @                                         # wire is vertical wire
       @for kwp in self.index.list(KeyWirePairL(wire.y1),KeyWirePairH(wire.y2)):
       @      get all horizontal vertices that lie in the vertical range of this wire
       @      check if they cross, and add to list cross_wires and from there compile in result			

```
![walking code colour anotation](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/_algos_6.006_ps3_code_walk.png)  
**Steps to optimise code: todo. . .**  
Adapt AVL tree code to implement rank & count.  
Implement LCA, Node-List, & List  
Integrate into circuit2.py  
Run profiler
sort lexicographic comparison

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  








### L9 - Table doubling, Karp-Rabin
[vid](https://www.youtube.com/watch?v=BRO7mVIFt08) ~ 
[lect notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec09.pdf)  
Code:
Reading:

**#### Vid contents**  
0-3m - 	Refresh Hashing with Chaining: Load factor  
3m - 	Resizing table, for optimum performance - Start small (constant) and grow (or shrink) as necessary.  
7m30 - 	Growing, allocate the memory & rehash all entries (w/ a hash function appropriet to new table size)  
15m - 	Amortisation - COST of table doubling operation calculated as a series   
21m - 	Inserts - Table doubling costs  
23m - 	Delete - Table downsizing  
23m46 - Delete - PROBLEM w/ table downsizing by half  
23m50 - Optimal upsized & downsize - double giong up only halve when n (entries) down to 1/4  
27m - strategy for implementing table doubling in an RTOS  
28m - String Matching  
34m - Cost for simple string matching theta Θ(s*t) could be QUADRATIC
35m - using a rolling hash ADT - concepts
41m-47m - Rolling hash ADT - pseudo code - problem set 4


How to choose m (table size)  - (on overflow double it)

When array becomes full n=m,  double in size m*2
When shrinking shrink when n gets to m/4 shrink m to m/2

** Invariant property: n <= m <= 4n ***
n has to be smaller than m (size of structure) or entries wont fit in the data structure
If n falls to m/4 halve structure size m = m/2, results in amortised  constant time

27m - listen to concept - table doubling in RTOS, to minimise rebuild time (and there minimise impact to latency) see [Alternatives to all-at-once rehashing](https://en.wikipedia.org/wiki/Hash_table).   
Term: amortised constant time - note on python lists

**String Matching**
 #### Rolling Hash ADT - 37m - Karp Rabin string matching
needed for Problem set 4 ? ps4
see notes p4

Rolling hash ADT - pseudo code. 41m - 47m  - 1987? getting more recent
	use choosing size using random prime 

rehash function: 4m41
https://www.youtube.com/watch?v=oxd_Z1osgCk
[c / c++ / python / java code](https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/)
```
Rehashing: hash(txt[s+1..s+m]) = d( hash(txt[s..s+m-1]) - txt[s]*h ) + txt[s+m]) mod q )
hash(txt[s+1..s+m]) = hash value @ shift s  
hash(txt[s..s+m-1]) = hash value @ next shift (s+1)
d: number of character in the alphabet (256 for 8bits)
q: prime number (laregr number = less collisions / false positives)
h: d^(m-1)

https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/ 
compiled local
https://github.com/UnacceptableBehaviour/gdb_lldb/blob/master/karp_rabin.cc
build instruction in file
```


### R9 - Rolling Hashes, Amortized Analysis
[vid](https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=32) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec09.pdf) ~ 
Code:
Reading: 

**#### Vid contents**  
0-5m -		Walk through naive implementation  
5m30-10m - Avoiding false positives / maths of collisions  
10m - 		Running time
14m - 		fast hashing - mod prime number  
18m-22m - 	SLIDE implementation  
22m - 		prehash - smart way  
28m - 		contsructor(__init__) for rolling_hash  
30m - 		append & skip  
36m-38 - 	modular / multiplicative inverse - precomputed because base on const  
40m - 		rolling_hash, append, skip, hash - cost  
52m - 		amortised analysis breakdown  
54m - 		listing BST nodes in order - In order traversal - amortised cost  
59m - 		amortised analysis - ps4  
	

Naive implementation of string match O(n*k), where n is string length & m is the search string length.
For each of he n positions each letter in k needs to be compared to the to search text.

For hashing the smaller the m (number of available spaces) the hash maps to the the higher the number of collisions (and in this application potential matches)
5m30-10m

Naively implements hash function for n character string will be O(n) - (10m30 - Assume O(1) using rolling hash)

**54m** Number of edges in a tree of N nodes is N-1  
Demonstrates intuitive proof of in order traversal in O(N) giving an amortized cost of O(1) per node < check understanding


#### Maths notes  
[Best from G4G](https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/) ~ 
Computation of [modular inverse](https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python) ~ 
[Using python built in pow()](https://docs.python.org/3/library/functions.html#pow) ~ 
[Wha?](https://www.kite.com/python/answers/how-to-calculate-modular-multiplicative-inverse-in-python)  
  
Multiplicative inverse / Modular inverse - 36m - also covered in R9b first 
add steps in calculation / proof - definition of modular inverse - revisit context  
```
Given two integers a and m, find modular multiplicative inverse of a under modulo m.

The modular multiplicative inverse is an integer x such that.
 a x ≡ 1 (mod m) 
The value of x should be in {0, 1, 2,  m-1}, i.e., in the range of integer modulo m.

The multiplicative inverse of a modulo m exists if and only if a and m are relatively prime (i.e., if gcd(a, m) = 1).
```

```
To calculate the inverse of 38 mod 97
>>> pow(38, -1, mod=97)
23
>>> 23 * 38 % 97 == 1
True

y = x**(p-2) mod p        # pseudocode
y = pow(x, p-2, p)        # python built ins

Fermat little theorem:
pow(x,m-1,m) must be 1     
Hence (pow(x,m-2,m) * x) % m == 1
So pow(x,m-2,m) is the inverse of x (mod m)
```


### R9b - 9b: DNA Sequence Matching  
[vid](https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=32) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/rec09b.pdf) ~ 
[Code Zip](http://ocw.mit.edu/ans7870/6/6.006/f11/ps4.tar.gz) ~ 
[Code git](https://github.com/UnacceptableBehaviour/algorithms/tree/master/problems/MIT6_006F11_ps4) ~ 
Reading: 

**#### Vid contents**  
**0m-1m** - 		what to cover? Hashes, Code & Amortisation  
**1m-3m** - 		Hashes, Extended Euclids Method, GCD greatest comm on divisor - modular multiplicative inverse  
**3m-14m** - 	Why using primes is important in hash function  
**13m6** - 		Caching - better to use time on a good mod (hash) function than use up all your memory - warm cache performs better   
**14m-00m** - 	Walk the code in problem set 4 ps4   
**15m** - 		Rollinghash, API diff - slide(new, old) split out into: append(new), skip(old),   
**16m20** - 		kfasta.py - iterator implemtaion, __iter__, next()  
**21m-44m** -  	dnaseq.py method by method & python features needed  
**21m** -  		implementing reverse w/o using a lot of memory 	
**23m-37m** - 	generators / yield / subsequences()   
**38n-40m** - 	intervalSubsequenceHashes(), concept of DRY code use subsequenceHashes() to implement  
**40m-44m** - 	getExactSubmatches()  
**44m** - 		Amortized analysis  
**49m-53m** - 	Time analysis list, append, memory alocation  
**53m** - 		Aggregate analysis / Cost based accounting  
**53m-57m** - 	Maths on aggregate analysis - write   
  
v2 contents  
  
| time			| notes	|
| **0m-1m** 		| what to cover? Hashes, Code & Amortisation  |
| **1m-3m** 		| Hashes, Extended Euclids Method, GCD greatest comm on divisor - modular multiplicative inverse  |
| **3m-14m** 	| Why using primes is important in hash function  |
| **13m6** 		| Caching - better to use time on a good mod (hash) function than use up all your memory - warm cache performs better   |
| **14m-00m** 	| Walk the code in problem set 4 ps4   |
| **15m** 		| Rollinghash, API diff - slide(new, old) split out into: append(new), skip(old),   |
| **16m20** 		| kfasta.py - iterator implemtaion, __iter__, next()  |
| **21m-44m** 	| dnaseq.py method by method & python features needed  |
| **21m** 		| implementing reverse w/o using a lot of memory 	|
| **23m-37m** 	| generators / yield / subsequences()   |
| **38n-40m** 	| intervalSubsequenceHashes(), concept of DRY code use subsequenceHashes() to implement  |
| **40m-44m** 	| getExactSubmatches()  |
| **44m** 		| Amortized analysis  |
| **49m-53m** 	| Time analysis list, append, memory alocation  |
| **53m** 		| Aggregate analysis / Cost based accounting  |
| **53m-57m**	| Maths on aggregate analysis - write |  

  
https://www.google.com/search?q=integrating+python+debugging+in+komodo&oq=integrating+python+debugger+in+komodo&aqs=chrome.1.69i57j33.16303j1j7&sourceid=chrome&ie=UTF-8

Generators:
```
def subsequences(seq, k):
    try:
        subseq = ''
        while True:
            while len(subseq) < k:
                subseq += seq.next()
            yield subseq
            subseq = subseq[1:]
    except StopIteration:
        return

for subseq in subsequences(seq, 3):
    print subseq
    i += 1

# another method for generating primes
def isPrime(n):
    if n < 2 or n % 1 > 0:
        return False
    elif n == 2 or n == 3:
        return True
    for x in range(2, int(n**0.5) + 1):
        if n % x == 0:
            return False
    return True

def getPrimes(value = 1):    
    while True:
        if isPrime(value):
            yield value
        value += 1

p2 = getPrimes()

while True
    table_size_m = next(p2)
    print(table_size_m)
```




#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  

13m6 reason to use prime over
p - 2^w / bla see 1st 2mins

44m Amortized analysis

Example using lists:
| 	list function 		| cost				|
| - | - |
|	l = list()			| 	O(1)	 		|
|	for list size N 	|					|
|	l.append()		|	O(N) worst case	|

The argument goes that since l.append() is O(1) and only O(N) infrequently, the amortised cost is O(N)
  
insertions + number of table doubles
\begin{align*}
  \sum_{n}{}O(1)+  \sum_{logn}{}O(2^i)\\
  gives\\
  O(n)+O(n)
\end{align*}
  
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Problem set 3 - Range Query (Analysis) / Circuit Layout (Tool optimisation)
[PDF here](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps3.pdf)  
[PS3 problem code]
### 3-1 Range Query - AVL tree


### 3-2 Tool Optimisation [55 points]
Overview of how this code work is in recitation 8
```
> python -m cProfile -s time circuit2.py < tests/10grid_s.in           # profile test - take nearly 15min!

> python -m cProfile -s time circuit2.py < tests/10grid_s.in
124668802
         1436321483 function calls (1436321412 primitive calls) in 917.681 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
187590314  279.644    0.000  428.213    0.000 circuit2.py:55(intersects)
    20000  195.692    0.010  366.372    0.018 circuit2.py:157(list)             < < < high tot.time
562840882  148.598    0.000  148.598    0.000 circuit2.py:47(is_horizontal)
        1  113.702  113.702  917.153  917.153 circuit2.py:336(_compute_crossings)      3
299400000  100.610    0.000  100.610    0.000 circuit2.py:246(__le__)
261444830   70.069    0.000   70.069    0.000 circuit2.py:256(__ge__)
124719049    8.749    0.000    8.749    0.000 {method 'append' of 'list' objects}
        1    0.135    0.135    0.371    0.371 circuit2.py:119(from_file)
    34970    0.108    0.000    0.146    0.000 circuit2.py:20(__init__)
        1    0.085    0.085    0.110    0.110 circuit2.py:327(_events_from_layer)
    20000    0.052    0.000    0.052    0.000 circuit2.py:281(__init__)
    34970    0.044    0.000    0.191    0.000 circuit2.py:99(add_wire)
        1    0.041    0.041    0.041    0.041 {method 'sort' of 'list' objects}
    34972    0.024    0.000    0.024    0.000 {method 'readline' of 'file' objects}
20460/20445    0.022    0.000    0.022    0.000 {len}
    34972    0.021    0.000    0.021    0.000 {method 'split' of 'str' objects}
    34970    0.021    0.000    0.021    0.000 circuit2.py:81(next_object_id)
    20000    0.017    0.000    0.017    0.000 circuit2.py:290(__init__)
    14970    0.013    0.000    0.013    0.000 circuit2.py:233(__init__)
    20000    0.009    0.000    0.009    0.000 circuit2.py:363(trace_sweep_line)
    20000    0.005    0.000    0.005    0.000 circuit2.py:51(is_vertical)
    14970    0.005    0.000    0.006    0.000 circuit2.py:147(add)
       57    0.003    0.000    0.003    0.000 {min}
        1    0.001    0.001  917.681  917.681 circuit2.py:3(<module>)                 2
        1    0.000    0.000  917.153  917.153 circuit2.py:313( )                      1
        1    0.000    0.000    0.151    0.151 circuit2.py:299(__init__)
        6    0.000    0.000    0.001    0.000 sre_parse.py:725(parse)
        9    0.000    0.000    0.000    0.000 sre_compile.py:428(_simple)
       80    0.000    0.000    0.000    0.000 sre_parse.py:207(match)
```

Profiler Qs  
```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     15/6    0.000    0.000    0.001    0.000 sre_parse.py:414(_parse)
```
Whats the 15/6 mean under ncalls? Recursive call here: 6 primitive call 15 in total  
  
Profiler column meanings: https://docs.python.org/3/library/profile.html
```
ncalls
    for the number of calls.
tottime
    for the total time spent in the given function (and excluding time made in calls to sub-functions)
percall
    is the quotient of tottime divided by ncalls
cumtime
    is the cumulative time spent in this and all subfunctions (from invocation till exit). This figure is accurate even for recursive functions.
percall
    is the quotient of cumtime divided by primitive calls
filename:lineno(function)
    provides the respective data of each function
```

  
**3-2 a)** list  
**3-2 a)** 187590314 calls - why per call time zero?  
**Setup for next questions**
```
Copy good_trace.jsonp to /circuit2/visualizer/bin/trace.jsonp         # its a trace of how sweeper should work
dbl click /circuit2/visualizer/bin/visualizer.html                    # or drag it into chrome
```   
![walking code colour anotation](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/_algos_6.006_ps3_code_walk.png)  
**Steps to optimise code: todo. . .**  
Adapt AVL tree code to implement rank & count.  
Implement LCA, Node-List, & List  
Integrate into circuit2.py  
Run profiler


#### REFS - alt profilers  
Using sProfile - https://towardsdatascience.com/how-to-profile-your-code-in-python-e70c834fad89  
Alternative profilers - https://pythonspeed.com/articles/beyond-cprofile/  
Python debugger - https://docs.python.org/3/library/pdb.html  
Python debugger tutorial - https://realpython.com/python-debugging-pdb/  
Alternative implementation to CPython - https://www.pypy.org/  
Working out if two vectors intersect + special cases - https://www.youtube.com/watch?v=bbTqI0oqL5U  
  
**Sweepline Algorithm Background**  
Sweep line algorithm 2/5 theory - https://www.youtube.com/watch?v=qkhUNzCGDt0  
  event (point) queue (use balanced BST) & sweepline status (use balanced BST)  
Sweep line algorithm 3/5 pseudo code - https://www.youtube.com/watch?v=I9EsN2DTnN8  
Sweep line algorithm 3/5 correctness proof (by induction)  - https://www.youtube.com/watch?v=8C3_ZKy4KkA  



### L10 - Open addressing, cryptographic hashing  
[vid](https://www.youtube.com/watch?v=rvdJDijO2Ro&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=10) ~ 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/lectures/lecture10.pdf)  
Code:
Reading: CLRS Chapter 11.4 (and 11.3.3 and 11.5 if interested)
[Collisions 6m refresh](https://www.youtube.com/watch?v=KyUTuwz_b7Q&t=720s) 5m open addressing: linear probing - 9m load factor & chaining: closed addressing

#### **DATA STRUCTURE**  
**type**:  
**use cases**: good for bla  
**queries**:  
**updates**:  
**(RI)**:   
**properties**:  

**#### Vid contents**  
**0m-3m** - 		Into - Open Addressing, Uniform hashing analysis, Cryptographic Hashing  
**3m30-m** - 	Open Addressing - no chaining = no pointers  
**8m** - 		Mapping from key through trial count to slots U x {0,1. . . m-1} > {0,1. . . m-1}  
**11m** - 		Eg of **INSERTION** w/ linear probing - see animation in **Collisions 6m refresh link at top!**  
**15m** - 		Eg of **SEARCH** w/ linear probing - see animation in **Collisions 6m refresh link at top!**  
**22m** - 		Coping w/ a search **after a deletion**! Inserts a DELETE_ME flag in place.  
**30m-00m** - 	Probing strategies  
**30m** - 		1 - linear probing  
**33m50** - 		clustering issue  
**36m** - 		Double hashing to **solve clustering**   
**39m** - 		Uniform Hashing Assumption - NOT same as SIMPLE Uniform hashing
**41m-46m** - 	Followed by Uniform Hashing **Analysis CRITICAL info!**  
**46m** - 		Cryptographic Hashing - NOT on quiz FYI only



**3m30 Open Addressing:**  
Linear probing: insert, search delete  
One item per slot so **m > n** (more array slots than items n)

U x {0,1. . . m-1}  >  {0,1. . . m-1}
U - universe of keys x trials count > slots in table

Notation for trials:  
h(k,0) 1st attempt to insert k  
h(k,1) 2nd attempt to insert k  
h(k,2) 3rd attempt to insert k  
etc

**30m - Probing Startegies - Linear Probing**  
hp - hprime is an ordinary hashing function   
i - tries  
m - table entries  
Problem with Linear probing hash function  
  
h(k,i) = (hp(k) +i ) mod m  
  
Permutation OK but has problems w/ clustering - when a CLUSTER STARTS TO FORM the probability of colliding w/ it GOES UP  
If  0.01 < alpha (load factor m/n) < 0.99  
then cluster size = Θ(logn) (35m20)  

**36m Double hashing to solve clustering**   
  
h(k,i) = (h1(k) + i*h2(k) ) mod m  

Term **relatively prime** - see maths below - follow up math insert formula - get intuition


**39m - Uniform hashing assumption**  
Each key is equally likely to have any one of the m! permutations as its probe sequence  
- not really true  
- but double hashing can come close  

Analysis: basically as table starts to fill alpha n/m (slots become fewer so load factor goes UP)
Cost if insert  <= 1/(1-alpha)
Add equations in latex
As alpha -> tends to 1 insert goes though the roof

Requires resize of table by time alpha gets to 0.5-0.6


**46m Cryptographic Hashing - Password**
Talks about one way cryptographic hashing for password.
So only meet to store


#### Example problem


#### Maths notes  
**Term "relatively prime" aka "coprime" or "mutually prime"**:  
When two numbers have no common factors other than 1.  
In other words there is no value that you could divide them both by exactly (without any remainder).  

Simplifying a fraction as much as possible with give a numerator and denominator that are **coprime**.
  
**EG**  
factors of 21 are 1,3,7,21  
factors of 22 are 1,2,11,22  
only common factor is 1 so they are relatively prime.  
  
21 and 24 are NOT relatively prime:  
factors of 21 are 1,3,7,21  
factors of 24 are 1,2,3,4,6,8,12,24  
common factors are 1 AND 3  



Why do we care?  



### R10 - Quiz 1 review
[vid](https://www.youtube.com/watch?v=-FElVPKykgw&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=34) - 
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/) - 
Code:
Reading: 

#### **DATA STRUCTURE**  
**type**:  
**use cases**: good for bla  
**queries**:  
**updates**:  
**(RI)**:   
**properties**: 

**#### Vid contents**  
**0m-3m** - 		Into - Open Addressing, Uniform hashing analysis, Cryptographic Hashing  
**3m30-5m** - 	Solving a Recursion problem  



#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Problem set 4
[PDF here](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps4.pdf) ~ 
[Code](http://ocw.mit.edu/ans7870/6/6.006/f11/ps4.tar.gz) ~ 
[git Solution Code]()





## Quiz 1	 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 4: Numerics
### L11 - Integer arithmetic, Karatsuba multiplication	
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  

### R11 - Principles of Algorithm Design
COPY RECITATION TEMPLATE into further lectures
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading: 

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



## Problem set 5 out

### L12 - Square roots, Newton's method	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 5: Graphs
### L13 - Breadth-first search (BFS)	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### L14	Depth-first search (DFS), topological sorting
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



## Problem set 5 due
## Problem set 6 out

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 6: Shortest Paths
### L15 - Single-source shortest paths problem	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### L16 - Dijkstra	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### L17 - Bellman-Ford	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### L18 - Speeding up Dijkstra
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



		Problem set 6 due
	 	Quiz 2	 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 7: Dynamic Programming
### L19 - Memoization, subproblems, guessing, bottom-up; Fibonacci, shortest paths
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  
0-5m - Introduction to Dynamic Programming (DP) recursion + memoization + guessing
5m-11m20 - Solving Fibonacci w/ Memoization - naive version
11m20-15m40 - Memoized version
15m40- running cost Θ(n) - **rule 30m49 flashback** for acyclic sub problems
19m30-23m - DP generalisation, running cost
23m-29m Bottom-up DP algorithm (topological sort)
29m-51m shortest paths, converting cyclic paths to acyclic & bellman-ford

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



## Problem set 7 out

### L20 - Parent pointers; text justification, perfect-information blackjack	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  




### L21 - String subproblems, psuedopolynomial time; parenthesization, edit distance, knapsack  
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### L22 - Two kinds of guessing; piano/guitar fingering, Tetris training, Super Mario Bros.[vid]()  
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



## Problem set 7 due

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## Unit 8: Advanced Topics
### L23 - Computational complexity	 
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  



### 24 - Algorithms research topics
[vid]()  
[lect notes](https://courses.csail.mit.edu/6.006/fall11/rec/)  
Code:
Reading:

#### **DATA STRUCTURE**  
type:  
use cases: good for bla  
queries:  
updates:  
representation invariant (RI):   
properties:  

#### Vid contents  

#### Example problem

#### Maths notes  
Any equation identities / topics for this lecture include context and uses for later reference  





## Glossary of terms

The following symbols o, Ω, ω, and Θ, are used to describe differing kinds of bounds on asymptotic growth rates.  
O - big O - describes the asymptotic behaviour of functions WORST case or UPPER bound (common in **CompSci**)  
Θ - big Theta - describes the asymptotic behaviour of functions AVERAGE case (common in **CompSci**)  
Ω - big Omega - BEST case or LOWER bound (common in **CompSci**)  
o - little O - loose upper bound (common in Maths rare in CompSci)  
ω - little omega - rough estimate of the order of the growth (rarely used)  
T(n) - function defining the exact Time or number of steps to complete an algorithm for n items  

Binary tree types:  
Full			All nodes have 2 children or 0 children (one child not allowed)  
Complete	Filled top to bottom left to right (and removed in reverse, data position likely re-ordered to preserve RI - EG Heap)  
Perfect		All layers have all their nodes  
Balanced	Usually refers to weight height balance leaf depths differ by no more than 1 (can also be weight balanced)

ADT - Abstract Data Type (interface definition, methods & properties)  
DS - Data Structure (actual implementation of the ADT)  
RI - representation invariant  

Stable sorting algorithm - A sorting algorithm is said to be stable if two objects with equal keys appear in the same order in sorted output as they appear in the input array to be sorted. 

Note for array of **any** size tree: element A[n/2+1 . . n] are ALL leaves! 


## How To s
### How so I plot a chart with python?
```
> .pe						# alias .pe='. venv/bin/activate'
> pip install matplotlib			# plotting lib
> pip install numpy				# math sci lib 
> ./matplotlib/plot.py				# super basic 2d plot example - in maths repo
```
[./matplotlib/time_complexity_plot_q.py](https://github.com/UnacceptableBehaviour/algorithms/blob/master/matplotlib/time_complexity_plot_q.py)  

### How to setup autogenerate README.md file from RTF notes?
```
> python --version			# Python 2.7.16
> python3 -m venv venv
> .pe					# alias .pe='. venv/bin/activate'
> python --version			# Python 3.7.5
> pip install --upgrade pip
> pip install striprtf			# for rtf processing
```

### How do I autogenerate README.md file from RTF?
```
> .pe				# alias .pe='. venv/bin/activate'
> ./create_TOC_for_md.py -p	# takes MATHS_00_MIT_6.042.rtf course notes and add TOC > README.md
				# also add README.md to git, commits, and pushes
				# -p = commit & push
```

### How can I add maths formulas to README.md?
#### Manually: Generate math image and embed it.
Install Latex tools [notes here](https://github.com/UnacceptableBehaviour/latex_maths/blob/master/context.md)  
Open LaTeXit edit equation click text and hit the LaTeXit button to check its good.  
Export as png and upload it to git (need to do this so the URL and be used to embed the image)  
Embed image with  
```
![uses dot product of the vector of each document](https://github.com/UnacceptableBehaviour/algorithms/blob/master/formulae/20200228_1715_dot_prod_doc_distance.png)  
Note the ! before opening [ denotes image
```
#### Automagically:  Install texify.
[Find texify here](https://github.com/agurodriguez/github-texify)  
Use LaTeXit to check formula correctness then past it into doc surrounded by consecutive \$ symbols like so
![latex script](https://github.com/UnacceptableBehaviour/latex_maths/blob/master/images/latex_example.png)  

Will display the following document distance equation  
$$
\begin{equation}
  D_1.D_2\\
\end{equation}
\begin{equation}
  \sum_{w}D_1[w].D_2[w]
  \label{sum}  
\end{equation}
$$

#### How can I get rid of ref numbers, or get them to increment at least?
open problem . .

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
## References
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Courses / Books Found w/ Summary:

MIT 2011 course
Prerequisite: Maths for CS: 
2015 https://www.youtube.com/watch?v=wIq4CssPoO0&list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ  
	[L3.2.1 Asymptotic Notation] (https://www.youtube.com/watch?v=CWkh5kb4TGc&list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ&index=72)  
	[L 3.2.3 Asymptotic Properties] (https://www.youtube.com/watch?v=HeyEK0TWiBw&list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ&index=73)  
	[L 3.2.6 Asymptotic Blunder inc Big O] (https://www.youtube.com/watch?v=Y9Blo_G-Mvg&list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ&index=74)  
2010 https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/  
	[L12 Sums] (https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/lecture-12-sums/)  
	[L12 Sums and Asymptotics] (https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/lecture-13-sums-and-asymptotics/)  

Topics: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/readings/  
Prerequisite: Probability: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041-probabilistic-systems-analysis-and-applied-probability-spring-2006/   
Assignments w solutions: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041-probabilistic-systems-analysis-and-applied-probability-spring-2006/assignments/    

### Intoduction to algorithms MIT (part 1 / 3):  
https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb  
Paper version: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/  
How Lectures Match problem sets:  
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/calendar/  
Problem Sets (inc code):  
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/  
Problem Local (inc code):/a_syllabus/_COURSES_03_TO_SORT/_algorithms/MIT_introduction_to_algorithms/_problems_exams  
Final exams & mocks: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/exams/  
Play list video: /a_syllabus/_COURSES_03_TO_SORT/_algorithms/MIT_introduction_to_algorithms/_Alogrithms_MIT_2011_vid.m3u  
Play list audio: /a_syllabus/_COURSES_03_TO_SORT/_algorithms/MIT_introduction_to_algorithms/_mp3/_Alogrithms_MIT_2011.m3u  

### LaTex example setup and doc repo: https://github.com/UnacceptableBehaviour/latex_maths  
Installing LaTex: http://tug.org/mactex/  
Latex Tutorial: https://www.youtube.com/watch?v=xnD4kHHvKhQ  
Maths in Latex: https://www.youtube.com/results?search_query=maths+formula+latex  

Follow up courses
### Design & Analysis of Algorithms (part 2 / 3)  
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/index.htm  
  
### Advanced Algorithms 2008 (part 3 / 3)  
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2008/  
  
 -   
 